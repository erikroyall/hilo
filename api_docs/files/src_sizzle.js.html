<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/sizzle.js - hilo</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="hilo"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0-pre-dev-beta-10</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/audioType.html">audioType</a></li>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
                <li><a href="../classes/feature.html">feature</a></li>
            
                <li><a href="../classes/hilo.html">hilo</a></li>
            
                <li><a href="../classes/iframe.html">iframe</a></li>
            
                <li><a href="../classes/NumberObject.html">NumberObject</a></li>
            
                <li><a href="../classes/Test.html">Test</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Hilo.html">Hilo</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/sizzle.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

  // querySelector pollyfill using Sizzle

  var sizzle = (function() {

    if (feature.qsa3 === true) {
      return;
    }

    /*!
     * Sizzle CSS Selector Engine v1.10.6-pre
     * http://sizzlejs.com/
     *
     * Copyright 2013 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     */

    var i,
      support,
      cachedruns = function () {
        var keys = [];

        function cache (key, value) {
          // Use (key + &quot; &quot;) to avoid collision 
          // with native prototype properties (see Issue #157)
          if (keys.push(key += &quot; &quot;) &gt; Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return (cache[key] = value);
        }
        return cache;
      },
      Expr,
      getText,
      isXML,
      compile,
      outermostContext,
      sortInput,

      // Local document vars
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,

      // Instance-specific data
      expando = &quot;sizzle&quot; + -(new Date()),
      preferredDoc = win.document,
      dirruns = 0,
      done = 0,
      classCache,
      tokenCache,
      compilerCache,
      hasDuplicate = false,
      sortOrder = function(a, b) {
        if (a === b) {
          hasDuplicate = true;

          return 0;
        }

        return 0;
      },

      // General-purpose constants
      strundefined = typeof undefined,
      MAX_NEGATIVE = 1 &lt;&lt; 31,

      // Instance methods
      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      // Use a stripped-down indexOf if we can&#x27;t use a native one
      indexOf = arr.indexOf || function(elem) {
        var i = 0,
          len = this.length;

        for (; i &lt; len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }

        return -1;
      },

      booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

      // Regular expressions

      // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,

      // http://www.w3.org/TR/css3-syntax/#characters
      characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,

      // Loosely modeled on CSS identifier characters
      // An unquoted value should be a CSS identifier 
      // http://www.w3.org/TR/css3-selectors/#attribute-selectors
      // Proper syntax: 
      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = characterEncoding.replace(&quot;w&quot;, &quot;w#&quot;),

      // Acceptable operators 
      // http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + 
        whitespace +
        &quot;*(?:([*^$|!~]?=)&quot; + whitespace + 
        &quot;*(?:([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + 
        whitespace + &quot;*\\]&quot;,

      // Prefer arguments quoted,
      //   then not containing pseudos/brackets,
      //   then attribute selectors/non-parenthetical expressions,
      //   then anything else
      // These preferences are here to reduce the number of selectors
      //   needing tokenize in the PSEUDO preFilter
      pseudos = &quot;:(&quot; + characterEncoding + 
        &quot;)(?:\\((([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|&quot; + 
        attributes.replace(3, 8) + &quot;)*)|.*)\\)|)&quot;,

      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rtrim = new RegExp(&quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + 
        whitespace + &quot;+$&quot;, &quot;g&quot;),

      rcomma = new RegExp(&quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot;),
      rcombinators = new RegExp(&quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace +
        &quot;)&quot; + whitespace + &quot;*&quot;),

      rsibling = new RegExp(whitespace + &quot;*[+~]&quot;),
      rattributeQuotes = new RegExp(&quot;=&quot; + whitespace + &quot;*([^\\]&#x27;\&quot;]*)&quot; + 
        whitespace + &quot;*\\]&quot;, &quot;g&quot;),

      rpseudo = new RegExp(pseudos ),
      ridentifier = new RegExp(&quot;^&quot; + identifier + &quot;$&quot; ),

      matchExpr = {
        &quot;ID&quot;: new RegExp(&quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;CLASS&quot;: new RegExp(&quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;TAG&quot;: new RegExp(&quot;^(&quot; + characterEncoding.replace(&quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
        &quot;ATTR&quot;: new RegExp(&quot;^&quot; + attributes ),
        &quot;PSEUDO&quot;: new RegExp(&quot;^&quot; + pseudos ),
        &quot;CHILD&quot;: new RegExp(&quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
          &quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
          &quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
        &quot;bool&quot;: new RegExp(&quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
        // For use in libraries implementing .is()
        // We use this for POS matching in &#x60;select&#x60;
        &quot;needsContext&quot;: new RegExp(&quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
          whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
      },

      rnative = /^[^{]+\{\s*\[native \w/,

      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,

      rescape = /&#x27;|\\/g,

      // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp(&quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + 
        whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
      
      funescape = function(_, escaped, escapedWhitespace) {
        var high = &quot;0x&quot; + escaped - 0x10000;

        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +&quot;0x&quot;
        return high !== high || escapedWhitespace ?
          escaped :
          // BMP codepoint
          high &lt; 0 ?
            String.fromCharCode(high + 0x10000) :
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00);
      };

    // Optimize for push.apply(_, NodeList)
    try {
      push.apply(
        (arr = slice.call(preferredDoc.childNodes)),
        preferredDoc.childNodes
     );
      // Support: Android&lt;4.0
      // Detect silently failing push.apply
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = { apply: arr.length ?

        // Leverage slice if possible
        function(target, els) {
          push_native.apply(target, slice.call(els));
        } :

        // Support: IE&lt;9
        // Otherwise append directly
        function(target, els) {
          var j = target.length,
            i = 0;
          // Can&#x27;t trust NodeList.length
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }
      };
    }

    /**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *  deleting the oldest entry
     */

    function select(selector, context, results, seed) {
      var i, tokens, token, type, find,
        match = tokenize(selector);

      if (!seed) {
        // Try to minimize operations if there is only one group
        if (match.length === 1) {

          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
              support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
              Expr.relative[tokens[1].type]) {

            context = (Expr.find[&quot;ID&quot;](token.matches[0].replace(runescape, 
              funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr[&quot;needsContext&quot;].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];

            // Abort if we hit a combinator
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {
              // Search, expanding context for leading sibling combinators
              if ((seed = find(
                token.matches[0].replace(runescape, funescape),
                rsibling.test(tokens[0].type) &amp;&amp; context.parentNode || context
             ))) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length &amp;&amp; toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        }
      }

      // Compile and execute a filtering function
      // Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
      compile(selector, match)(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test(selector)
     );
      return results;
    }

    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }

      context = context || document;
      results = results || [];

      if (!selector || typeof selector !== &quot;string&quot;) {
        return results;
      }

      if ((nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9) {
        return [];
      }

      if (documentIsHTML &amp;&amp; !seed) {

        // Shortcuts
        if ((match = rquickExpr.exec(selector))) {
          // Speed-up: Sizzle(&quot;#ID&quot;)
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963
              if (elem &amp;&amp; elem.parentNode) {
                // Handle the case where IE, Opera, and Webkit return items
                // by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              // Context is not a document
              if (context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById(m)) &amp;&amp;
                contains(context, elem) &amp;&amp; elem.id === m) {
                results.push(elem);
                return results;
              }
            }

          // Speed-up: Sizzle(&quot;TAG&quot;)
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;

          // Speed-up: Sizzle(&quot;.CLASS&quot;)
          } else if ((m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }

        // QSA path
        if (support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 &amp;&amp; selector;

          // qSA works strangely on Element-rooted queries
          // We can work around this by specifying an extra ID on the root
          // and working up from there (Thanks to Andrew Dupont for the technique)
          // IE 8 doesn&#x27;t work on object elements
          if (nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot;) {
            groups = tokenize(selector);

            if ((old = context.getAttribute(&quot;id&quot;))) {
              nid = old.replace(rescape, &quot;\\$&amp;&quot;);
            } else {
              context.setAttribute(&quot;id&quot;, nid);
            }
            nid = &quot;[id=&#x27;&quot; + nid + &quot;&#x27;] &quot;;

            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) &amp;&amp; context.parentNode || context;
            newSelector = groups.join(&quot;,&quot;);
          }

          if (newSelector) {
            try {
              push.apply(results,
                newContext.querySelectorAll(newSelector)
             );
              return results;
            } catch(qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute(&quot;id&quot;);
              }
            }
          }
        }
      }

      // All others
      return select(selector.replace(rtrim, &quot;$1&quot;), context, results, seed);
    }

    function createCache () {
      var keys = [];

      function cache(key, value) {
        // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key += &quot; &quot;) &gt; Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }
        return (cache[key] = value);
      }
      return cache;
    }


    classCache = createCache();
    tokenCache = createCache();
    compilerCache = createCache();

    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }

    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */
    function assert(fn) {
      var div = document.createElement(&quot;div&quot;);

      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        // release memory in IE
        div = null;
      }
    }

    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle(attrs, handler) {
      var arr = attrs.split(&quot;|&quot;),
        i = attrs.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }

    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck(a, b) {
      var cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);

      // Use IE sourceIndex if available on both nodes
      if (diff) {
        return diff;
      }

      // Check if b follows a
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }

    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === &quot;input&quot; &amp;&amp; elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;

          // Match elements found at the specified indexes
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }

    /**
     * Detect xml
     * @param {Element|Object} elem An element or a document
     */
    isXML = Sizzle.isXML = function(elem) {
      // documentElement is verified for cases where it doesn&#x27;t yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
    };

    // Expose support vars for convenience
    support = Sizzle.support = {};

    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function(node) {
      var doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

      // If no document and documentElement is available, return
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }

      // Set our document
      document = doc;
      docElem = doc.documentElement;

      // Support tests
      documentIsHTML = !isXML(doc);

      // Support: IE&gt;8
      // If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,
      // IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936
      // IE6-8 do not support the defaultView property so parent will be undefined
      if (parent &amp;&amp; parent.attachEvent &amp;&amp; parent !== parent.top) {
        parent.attachEvent(&quot;onbeforeunload&quot;, function() {
          setDocument();
        });
      }

      /* Attributes
      ---------------------------------------------------------------------- */

      // Support: IE&lt;8
      // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
      support.attributes = assert(function(div) {
        div.className = &quot;i&quot;;
        return !div.getAttribute(&quot;className&quot;);
      });

      /* getElement(s)By*
      ---------------------------------------------------------------------- */

      // Check if getElementsByTagName(&quot;*&quot;) returns only elements
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(&quot;&quot;));
        return !div.getElementsByTagName(&quot;*&quot;).length;
      });

      // Check if getElementsByClassName can be trusted
      support.getElementsByClassName = assert(function(div) {
        div.innerHTML = &quot;&lt;div class=&#x27;a&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;a i&#x27;&gt;&lt;/div&gt;&quot;;

        // Support: Safari&lt;4
        // Catch class over-caching
        div.firstChild.className = &quot;i&quot;;
        // Support: Opera&lt;10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName(&quot;i&quot;).length === 2;
      });

      // Support: IE&lt;10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don&#x27;t pick up programatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });

      // ID find and filter
      if (support.getById) {
        Expr.find[&quot;ID&quot;] = function(id, context) {
          if (typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML) {
            var m = context.getElementById(id);
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            return m &amp;&amp; m.parentNode ? [m] : [];
          }
        };
        Expr.filter[&quot;ID&quot;] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute(&quot;id&quot;) === attrId;
          };
        };
      } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find[&quot;ID&quot;];

        Expr.filter[&quot;ID&quot;] =  function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
            return node &amp;&amp; node.value === attrId;
          };
        };
      }

      // Tag
      Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
        function(tag, context) {
          if (typeof context.getElementsByTagName !== strundefined) {
            return context.getElementsByTagName(tag);
          }
        } :
        function(tag, context) {
          var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);

          // Filter out possible comments
          if (tag === &quot;*&quot;) {
            while ((elem = results[i++])) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }
          return results;
        };

      // Class
      Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function(className, context) {
        if (typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };

      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */

      // QSA and matchesSelector support

      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];

      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever &#x60;document.activeElement&#x60; is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See http://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];

      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function(div) {
          // Select is set to empty string on purpose
          // This is to test IE&#x27;s treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // http://bugs.jquery.com/ticket/12359
          div.innerHTML = &quot;&lt;select&gt;&lt;option selected=&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

          // Support: IE8
          // Boolean attributes and &quot;value&quot; are not treated correctly
          if (!div.querySelectorAll(&quot;[selected]&quot;).length) {
            rbuggyQSA.push(&quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot;);
          }

          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if (!div.querySelectorAll(&quot;:checked&quot;).length) {
            rbuggyQSA.push(&quot;:checked&quot;);
          }
        });

        assert(function(div) {

          // Support: Opera 10-12/IE8
          // ^= $= *= and empty values
          // Should not select anything
          // Support: Windows 8 Native Apps
          // The type attribute is restricted during .innerHTML assignment
          var input = doc.createElement(&quot;input&quot;);
          input.setAttribute(&quot;type&quot;, &quot;hidden&quot;);
          div.appendChild(input).setAttribute(&quot;t&quot;, &quot;&quot;);

          if (div.querySelectorAll(&quot;[t^=&#x27;&#x27;]&quot;).length) {
            rbuggyQSA.push(&quot;[*^$]=&quot; + whitespace + &quot;*(?:&#x27;&#x27;|\&quot;\&quot;)&quot;);
          }

          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if (!div.querySelectorAll(&quot;:enabled&quot;).length) {
            rbuggyQSA.push(&quot;:enabled&quot;, &quot;:disabled&quot;);
          }

          // Opera 10-11 does not throw on post-comma invalid pseudos
          div.querySelectorAll(&quot;*,:x&quot;);
          rbuggyQSA.push(&quot;,.*:&quot;);
        });
      }

      if ((support.matchesSelector = rnative.test((matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector)))) {

        assert(function(div) {
          // Check to see if it&#x27;s possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(div, &quot;div&quot;);

          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call(div, &quot;[s!=&#x27;&#x27;]:x&quot;);
          rbuggyMatches.push(&quot;!=&quot;, pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp(rbuggyQSA.join(&quot;|&quot;));
      rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp(rbuggyMatches.join(&quot;|&quot;));

      /* Contains
      ---------------------------------------------------------------------- */

      // Element contains another
      // Purposefully does not implement inclusive descendent
      // As in, an element does not contain itself
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ?
        function(a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
          return a === bup || !!(bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
            adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; 16
         ));
        } :
        function(a, b) {
          if (b) {
            while ((b = b.parentNode)) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };

      /* Sorting
      ---------------------------------------------------------------------- */

      // Document order sorting
      sortOrder = docElem.compareDocumentPosition ?
      function(a, b) {

        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(b);

        if (compare) {
          // Disconnected nodes
          if (compare &amp; 1 ||
            (!support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare)) {

            // Choose the first element that is related to our preferred document
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }

            // Maintain original order
            return sortInput ?
              (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
              0;
          }

          return compare &amp; 4 ? -1 : 1;
        }

        // Not directly comparable, sort on existence of method
        return a.compareDocumentPosition ? -1 : 1;
      } :
      function(a, b) {
        var cur,
          i = 0,
          aup = a.parentNode,
          bup = b.parentNode,
          ap = [a],
          bp = [b];

        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;

        // Parentless nodes are either documents or disconnected
        } else if (!aup || !bup) {
          return a === doc ? -1 :
            b === doc ? 1 :
            aup ? -1 :
            bup ? 1 :
            sortInput ?
            (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
            0;

        // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }

        // Walk down the tree looking for a discrepancy
        while (ap[i] === bp[i]) {
          i++;
        }

        return i ?
          // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i], bp[i]) :

          // Otherwise nodes in our document sort first
          ap[i] === preferredDoc ? -1 :
          bp[i] === preferredDoc ? 1 :
          0;
      };

      return doc;
    };

    // Sizzle.matches = function(expr, elements) {
    //   return Sizzle(expr, null, null, elements);
    // };

    Sizzle.matchesSelector = function(elem, expr) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      // Make sure that attribute selectors are quoted
      expr = expr.replace(rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot;);

      if (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp;
        (!rbuggyQSA     || !rbuggyQSA.test(expr))) {

        try {
          var ret = matches.call(elem, expr);

          // IE 9&#x27;s matchesSelector returns false on disconnected nodes
          if (ret || support.disconnectedMatch ||
              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document &amp;&amp; elem.document.nodeType !== 11) {
            return ret;
          }
        } catch(e) {}
      }

      return Sizzle(expr, document, null, [elem]).length &gt; 0;
    };

    Sizzle.contains = function(context, elem) {
      // Set document vars if needed
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };

    Sizzle.attr = function(elem, name) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
        // Don&#x27;t get fooled by Object.prototype properties (jQuery #13807)
        val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          undefined;

      return val === undefined ?
        support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            null :
        val;
    };

    Sizzle.error = function(msg) {
      throw new Error(&quot;Syntax error, unrecognized expression: &quot; + msg);
    };

    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function(results) {
      var elem,
        duplicates = [],
        j = 0,
        i = 0;

      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable &amp;&amp; results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }

      return results;
    };

    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function(elem) {
      var node,
        ret = &quot;&quot;,
        i = 0,
        nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        for (; (node = elem[i]); i++) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (see #11153)
        if (typeof elem.textContent === &quot;string&quot;) {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes

      return ret;
    };

    Expr = Sizzle.selectors = {

      // Can be adjusted by the user
      cacheLength: 50,

      createPseudo: markFunction,

      match: matchExpr,

      attrHandle: {},

      find: {},

      relative: {
        &quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
        &quot; &quot;: { dir: &quot;parentNode&quot; },
        &quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
        &quot;~&quot;: { dir: &quot;previousSibling&quot; }
      },

      preFilter: {
        &quot;ATTR&quot;: function(match) {
          match[1] = match[1].replace(runescape, funescape);

          // Move the given value to match[3] whether quoted or unquoted
          match[3] = (match[4] || match[5] || &quot;&quot;).replace(runescape, funescape);

          if (match[2] === &quot;~=&quot;) {
            match[3] = &quot; &quot; + match[3] + &quot; &quot;;
          }

          return match.slice(0, 4);
        },

        &quot;CHILD&quot;: function(match) {
          /* matches from matchExpr[&quot;CHILD&quot;]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === &quot;nth&quot;) {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            }

            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === &quot;even&quot; || match[3] === &quot;odd&quot;));
            match[5] = +((match[7] + match[8]) || match[3] === &quot;odd&quot;);

          // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },

        &quot;PSEUDO&quot;: function(match) {
          var excess,
            unquoted = !match[5] &amp;&amp; match[2];

          if (matchExpr[&quot;CHILD&quot;].test(match[0])) {
            return null;
          }

          // Accept quoted arguments as-is
          if (match[3] &amp;&amp; match[4] !== undefined) {
            match[2] = match[4];

          // Strip excess characters from unquoted arguments
          } else if (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp;
            // Get excess from tokenize (recursively)
            (excess = tokenize(unquoted, true)) &amp;&amp;
            // advance to the next closing parenthesis
            (excess = unquoted.indexOf(&quot;)&quot;, unquoted.length - excess) - unquoted.length)) {

            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }

          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice(0, 3);
        }
      },

      filter: {

        &quot;TAG&quot;: function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === &quot;*&quot; ?
            function() { return true; } :
            function(elem) {
              return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
            };
        },

        &quot;CLASS&quot;: function(className) {
          var pattern = classCache[className + &quot; &quot;];

          return pattern ||
            (pattern = new RegExp(&quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot;)) &amp;&amp;
            classCache(className, function(elem) {
              return pattern.test(typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot;);
            });
        },

        &quot;ATTR&quot;: function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === &quot;!=&quot;;
            }
            if (!operator) {
              return true;
            }

            result += &quot;&quot;;

            return operator === &quot;=&quot; ? result === check :
              operator === &quot;!=&quot; ? result !== check :
              operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf(check) === 0 :
              operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf(check) &gt; -1 :
              operator === &quot;$=&quot; ? check &amp;&amp; result.slice(-check.length) === check :
              operator === &quot;~=&quot; ? (&quot; &quot; + result + &quot; &quot;).indexOf(check) &gt; -1 :
              operator === &quot;|=&quot; ? result === check || result.slice(0, check.length + 1) === check + &quot;-&quot; :
              false;
          };
        },

        &quot;CHILD&quot;: function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== &quot;nth&quot;,
            forward = type.slice(-4) !== &quot;last&quot;,
            ofType = what === &quot;of-type&quot;;

          return first === 1 &amp;&amp; last === 0 ?

            // Shortcut for :nth-*(n)
            function(elem) {
              return !!elem.parentNode;
            } :

            function(elem, context, xml) {
              var cache, outerCache, node, diff, nodeIndex, start,
                dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
                parent = elem.parentNode,
                name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                useCache = !xml &amp;&amp; !ofType;

              if (parent) {

                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;
                    while ((node = node[dir])) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    }
                    // Reverse direction for :only-* (if we haven&#x27;t yet done so)
                    start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
                  }
                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild];

                // non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
                if (forward &amp;&amp; useCache) {
                  // Seek &#x60;elem&#x60; from a previously-cached index
                  outerCache = parent[expando] || (parent[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
                  diff = cache[0] === dirruns &amp;&amp; cache[2];
                  node = nodeIndex &amp;&amp; parent.childNodes[nodeIndex];

                  while ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||

                    // Fallback to seeking &#x60;elem&#x60; from the start
                    (diff = nodeIndex = 0) || start.pop())) {

                    // When found, cache indexes on &#x60;parent&#x60; and break
                    if (node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem) {
                      outerCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }

                // Use previously-cached element index if available
                } else if (useCache &amp;&amp; (cache = (elem[expando] || (elem[expando] = {}))[type]) &amp;&amp; cache[0] === dirruns) {
                  diff = cache[1];

                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                } else {
                  // Use the same loop as above to seek &#x60;elem&#x60; from the start
                  while ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||
                    (diff = nodeIndex = 0) || start.pop())) {

                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) &amp;&amp; ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }

                // Incorporate the offset, then check against cycle size
                diff -= last;
                return diff === first || (diff % first === 0 &amp;&amp; diff / first &gt;= 0);
              }
            };
        },

        &quot;PSEUDO&quot;: function(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that SetFilters inherits from pseudos
          var args,
            fn = Expr.pseudos[pseudo] || Expr.SetFilters[pseudo.toLowerCase()] ||
              Sizzle.error(&quot;unsupported pseudo: &quot; + pseudo);

          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if (fn[expando]) {
            return fn(argument);
          }

          // But maintain support for old signatures
          if (fn.length &gt; 1) {
            args = [pseudo, pseudo, &quot;&quot;, argument];
            return Expr.SetFilters.hasOwnProperty(pseudo.toLowerCase()) ?
              markFunction(function(seed, matches) {
                var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
                while (i--) {
                  idx = indexOf.call(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) :
              function(elem) {
                return fn(elem, 0, args);
              };
          }

          return fn;
        }
      },

      pseudos: {
        // Potentially complex pseudos
        &quot;not&quot;: markFunction(function(selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, &quot;$1&quot;));

          return matcher[expando] ?
            markFunction(function(seed, matches, context, xml) {
              var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;

              // Match elements unmatched by &#x60;matcher&#x60;
              while (i--) {
                if ((elem = unmatched[i])) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) :
            function(elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              return !results.pop();
            };
        }),

        &quot;has&quot;: markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length &gt; 0;
          };
        }),

        &quot;contains&quot;: markFunction(function(text) {
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) &gt; -1;
          };
        }),

        // &quot;Whether an element is represented by a :lang() selector
        // is based solely on the element&#x27;s language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by &quot;-&quot;.
        // The matching of C against the element&#x27;s language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name.&quot;
        // http://www.w3.org/TR/selectors/#lang-pseudo
        &quot;lang&quot;: markFunction(function(lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || &quot;&quot;)) {
            Sizzle.error(&quot;unsupported lang: &quot; + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ?
                elem.lang :
                elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;))) {

                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + &quot;-&quot;) === 0;
              }
            } while ((elem = elem.parentNode) &amp;&amp; elem.nodeType === 1);
            return false;
          };
        }),

        // Miscellaneous
        &quot;target&quot;: function(elem) {
          var hash = win.location &amp;&amp; win.location.hash;
          return hash &amp;&amp; hash.slice(1) === elem.id;
        },

        &quot;root&quot;: function(elem) {
          return elem === docElem;
        },

        &quot;focus&quot;: function(elem) {
          return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        &quot;enabled&quot;: function(elem) {
          return elem.disabled === false;
        },

        &quot;disabled&quot;: function(elem) {
          return elem.disabled === true;
        },

        &quot;checked&quot;: function(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
        },

        &quot;selected&quot;: function(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },

        // Contents
        &quot;empty&quot;: function(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
          //   not comment, processing instructions, or others
          // Thanks to Diego Perini for the nodeName shortcut
          //   Greater than &quot;@&quot; means alpha characters (specifically not starting with &quot;#&quot; or &quot;?&quot;)
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName &gt; &quot;@&quot; || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },

        &quot;parent&quot;: function(elem) {
          return !Expr.pseudos[&quot;empty&quot;](elem);
        },

        // Element/input types
        &quot;header&quot;: function(elem) {
          return rheader.test(elem.nodeName);
        },

        &quot;input&quot;: function(elem) {
          return rinputs.test(elem.nodeName);
        },

        &quot;button&quot;: function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
        },

        &quot;text&quot;: function(elem) {
          var attr;
          // IE6 and 7 will map elem.type to &#x27;text&#x27; for new HTML5 types (search, etc)
          // use getAttribute instead to test this case
          return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
            elem.type === &quot;text&quot; &amp;&amp;
            ((attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === elem.type);
        },

        // Position-in-collection
        &quot;first&quot;: createPositionalPseudo(function() {
          return [0];
        }),

        &quot;last&quot;: createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),

        &quot;eq&quot;: createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument &lt; 0 ? argument + length : argument];
        }),

        &quot;even&quot;: createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i &lt; length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        &quot;odd&quot;: createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i &lt; length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        &quot;lt&quot;: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument &lt; 0 ? argument + length : argument;
          for (; --i &gt;= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),

        &quot;gt&quot;: createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument &lt; 0 ? argument + length : argument;
          for (; ++i &lt; length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };

    Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

    // Add button/input type pseudos
    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }

    // Easy API for creating new SetFilters
    function SetFilters() {}
    SetFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.SetFilters = new SetFilters();

    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[selector + &quot; &quot;];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {

        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don&#x27;t consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }

        matched = false;

        // Combinators
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, &quot; &quot;)
          });
          soFar = soFar.slice(matched.length);
        }

        // Filters
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] ||
            (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      }

      // Return the length of the invalid excess
      // if we&#x27;re just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ?
        soFar.length :
        soFar ?
          Sizzle.error(selector) :
          // Cache the tokens
          tokenCache(selector, groups).slice(0);
    }

    function toSelector(tokens) {
      var i = 0,
        len = tokens.length,
        selector = &quot;&quot;;
      for (; i &lt; len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
        doneName = done++;

      return combinator.first ?
        // Check against closest ancestor/preceding element
        function(elem, context, xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
        } :

        // Check against all ancestor/preceding elements
        function(elem, context, xml) {
          var data, cache, outerCache,
            dirkey = dirruns + &quot; &quot; + doneName;

          // We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from dir caching
          if (xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                if ((cache = outerCache[dir]) &amp;&amp; cache[0] === dirkey) {
                  if ((data = cache[1]) === true || data === cachedruns) {
                    return data === true;
                  }
                } else {
                  cache = outerCache[dir] = [dirkey];
                  cache[1] = matcher(elem, context, xml) || cachedruns;
                  if (cache[1] === true) {
                    return true;
                  }
                }
              }
            }
          }
        };
    }

    function elementMatcher(matchers) {
      return matchers.length &gt; 1 ?
        function(elem, context, xml) {
          var i = matchers.length;
          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } :
        matchers[0];
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

      for (; i &lt; len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter &amp;&amp; !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder &amp;&amp; !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp, i, elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,

          // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || &quot;*&quot;, context.nodeType ? [context] : context, []),

          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter &amp;&amp; (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,

          matcherOut = matcher ?
            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || (seed ? preFilter : preexisting || postFilter) ?

              // ...intermediate processing is necessary
              [] :

              // ...otherwise use results directly
              results :
            matcherIn;

        // Find primary matches
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }

        // Apply postFilter
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);

          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }

            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) &amp;&amp;
                (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) &gt; -1) {

                seed[temp] = !(results[temp] = elem);
              }
            }
          }

        // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(
            matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
         );
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[0].type],
        implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true),
        matchAnyContext = addCombinator(function(elem) {
          return indexOf.call(checkContext, elem) &gt; -1;
        }, implicitRelative, true),
        matchers = [function(elem, context, xml) {
          return (!leadingRelative &amp;&amp; (xml || context !== outermostContext)) || (
            (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
        }];

      for (; i &lt; len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

          // Return special upon seeing a positional matcher
          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for (; j &lt; len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(
              i &gt; 1 &amp;&amp; elementMatcher(matchers),
              i &gt; 1 &amp;&amp; toSelector(
                // If the preceding token was a descendant combinator, insert an implicit any-element &#x60;*&#x60;
                tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
             ).replace(rtrim, &quot;$1&quot;),
              matcher,
              i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)),
              j &lt; len &amp;&amp; matcherFromTokens((tokens = tokens.slice(j))),
              j &lt; len &amp;&amp; toSelector(tokens)
           );
          }
          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      // A counter to specify which element is currently being matched
      var matcherCachedRuns = 0,
        bySet = setMatchers.length &gt; 0,
        byElement = elementMatchers.length &gt; 0,
        superMatcher = function(seed, context, xml, results, expandContext) {
          var elem, j, matcher,
            setMatched = [],
            matchedCount = 0,
            i = &quot;0&quot;,
            unmatched = seed &amp;&amp; [],
            outermost = expandContext != null,
            contextBackup = outermostContext,
            // We must always have either seed elements or context
            elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;](&quot;*&quot;, expandContext &amp;&amp; context.parentNode || context),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
            len = elems.length;

          if (outermost) {
            outermostContext = context !== document &amp;&amp; context;
            cachedruns = matcherCachedRuns;
          }

          // Add elements passing elementMatchers directly to results
          // Keep &#x60;i&#x60; a string if there are no elements so &#x60;matchedCount&#x60; will be &quot;00&quot; below
          // Support: IE&lt;9, Safari
          // Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
          for (; i !== len &amp;&amp; (elem = elems[i]) != null; i++) {
            if (byElement &amp;&amp; elem) {
              j = 0;
              while ((matcher = elementMatchers[j++])) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }

            // Track unmatched elements for set filters
            if (bySet) {
              // They will have gone through all possible matchers
              if ((elem = !matcher &amp;&amp; elem)) {
                matchedCount--;
              }

              // Lengthen the array for every element, matched or not
              if (seed) {
                unmatched.push(elem);
              }
            }
          }

          // Apply set filters to unmatched elements
          matchedCount += i;
          if (bySet &amp;&amp; i !== matchedCount) {
            j = 0;
            while ((matcher = setMatchers[j++])) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount &gt; 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }

              // Discard index placeholder values to get only actual matches
              setMatched = condense(setMatched);
            }

            // Add matches to results
            push.apply(results, setMatched);

            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if (outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
              (matchedCount + setMatchers.length) &gt; 1) {

              Sizzle.uniqueSort(results);
            }
          }

          // Override manipulation of globals by nested matchers
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

      return bySet ?
        markFunction(superMatcher) :
        superMatcher;
    }

    compile = Sizzle.compile = function(selector, group /* Internal Use Only */) {
      var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + &quot; &quot;];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }

        // Cache the compiled function
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };

    function multipleContexts(selector, contexts, results) {
      var i = 0,
        len = contexts.length;
      for (; i &lt; len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }

    // One-time assignments

    // Sort stability
    support.sortStable = expando.split(&quot;&quot;).sort(sortOrder).join(&quot;&quot;) === expando;

    // Support: Chrome&lt;14
    // Always assume duplicates if they aren&#x27;t passed to the comparison function
    support.detectDuplicates = hasDuplicate;

    // Initialize against the default document
    setDocument();

    // Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function(div1) {
      // Should return 1, but returns 4 (following)
      return div1.compareDocumentPosition(document.createElement(&quot;div&quot;)) &amp; 1;
    });

    // Support: IE&lt;8
    // Prevent attribute/property &quot;interpolation&quot;
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!assert(function(div) {
      div.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
      return div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
    })) {
      addHandle(&quot;type|href|height|width&quot;, function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === &quot;type&quot; ? 1 : 2);
        }
      });
    }

    // Support: IE&lt;9
    // Use defaultValue in place of getAttribute(&quot;value&quot;)
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = &quot;&lt;input/&gt;&quot;;
      div.firstChild.setAttribute(&quot;value&quot;, &quot;&quot;);
      return div.firstChild.getAttribute(&quot;value&quot;) === &quot;&quot;;
    })) {
      addHandle(&quot;value&quot;, function(elem, name, isXML) {
        if (!isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot;) {
          return elem.defaultValue;
        }
      });
    }

    // Support: IE&lt;9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if (!assert(function(div) {
      return div.getAttribute(&quot;disabled&quot;) == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }

    return Sizzle;

  }());
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
