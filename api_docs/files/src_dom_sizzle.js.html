<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\dom\sizzle.js - hilo</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html"><img src="../assets/css/logo.png">hilo: src\dom\sizzle.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0-pre-dev-beta-9</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Modules</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/Hilo.html">Hilo</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/Dom.html">Dom</a></li>
            
        </ul>
    </div>
</div>










<div id="fileTree" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Files</h2>
    </div>
    <div class="bd">
        <ul><li>src\ajax\main.js/<ul></ul></li><li>src\core.js/<ul></ul></li><li>src\dom\class-id.js/<ul></ul></li><li>src\dom\main.js/<ul></ul></li><li>src\dom\sizzle.js/<ul></ul></li></ul>
    </div>
</div>



        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>src\dom\sizzle.js</h4>

<pre class="code prettyprint linenums">

  // querySelector pollyfill using Sizzle

  sizzle = (function(){

    if (feature.qsa3 === true) {
      return;
    }

    /*!
     * Sizzle CSS Selector Engine v1.10.6-pre
     * http://sizzlejs.com/
     *
     * Copyright 2013 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     */

    var i,
      support,
      cachedruns = function () {
        var keys = [];

        function cache( key, value ) {
          // Use (key + &quot; &quot;) to avoid collision 
          // with native prototype properties (see Issue #157)
          if ( keys.push( key += &quot; &quot; ) &gt; Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
          }
          return (cache[ key ] = value);
        }
        return cache;
      },
      Expr,
      getText,
      isXML,
      compile,
      outermostContext,
      sortInput,

      // Local document vars
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,

      // Instance-specific data
      expando = &quot;sizzle&quot; + -(new Date()),
      preferredDoc = win.document,
      dirruns = 0,
      done = 0,
      classCache,
      tokenCache,
      compilerCache,
      hasDuplicate = false,
      sortOrder = function( a, b ) {
        if ( a === b ) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      },

      // General-purpose constants
      strundefined = typeof undefined,
      MAX_NEGATIVE = 1 &lt;&lt; 31,

      // Instance methods
      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      // Use a stripped-down indexOf if we can&#x27;t use a native one
      indexOf = arr.indexOf || function( elem ) {
        var i = 0,
          len = this.length;
        for ( ; i &lt; len; i++ ) {
          if ( this[i] === elem ) {
            return i;
          }
        }
        return -1;
      },

      booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

      // Regular expressions

      // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
      // http://www.w3.org/TR/css3-syntax/#characters
      characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,

      // Loosely modeled on CSS identifier characters
      // An unquoted value should be a CSS identifier 
      // http://www.w3.org/TR/css3-selectors/#attribute-selectors
      // Proper syntax: 
      // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),

      // Acceptable operators 
      // http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + 
        whitespace +
        &quot;*(?:([*^$|!~]?=)&quot; + whitespace + 
        &quot;*(?:([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + 
        whitespace + &quot;*\\]&quot;,

      // Prefer arguments quoted,
      //   then not containing pseudos/brackets,
      //   then attribute selectors/non-parenthetical expressions,
      //   then anything else
      // These preferences are here to reduce the number of selectors
      //   needing tokenize in the PSEUDO preFilter
      pseudos = &quot;:(&quot; + characterEncoding + 
        &quot;)(?:\\((([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|&quot; + 
        attributes.replace( 3, 8 ) + &quot;)*)|.*)\\)|)&quot;,

      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + 
        whitespace + &quot;+$&quot;, &quot;g&quot; ),

      rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
      rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace +
        &quot;)&quot; + whitespace + &quot;*&quot; ),

      rsibling = new RegExp( whitespace + &quot;*[+~]&quot; ),
      rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&#x27;\&quot;]*)&quot; + 
        whitespace + &quot;*\\]&quot;, &quot;g&quot; ),

      rpseudo = new RegExp( pseudos ),
      ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

      matchExpr = {
        &quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
        &quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
        &quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
        &quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
          &quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
          &quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
        &quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
        // For use in libraries implementing .is()
        // We use this for POS matching in &#x60;select&#x60;
        &quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
          whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
      },

      rnative = /^[^{]+\{\s*\[native \w/,

      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,

      rescape = /&#x27;|\\/g,

      // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + 
        whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
      funescape = function( _, escaped, escapedWhitespace ) {
        var high = &quot;0x&quot; + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +&quot;0x&quot;
        return high !== high || escapedWhitespace ?
          escaped :
          // BMP codepoint
          high &lt; 0 ?
            String.fromCharCode( high + 0x10000 ) :
            // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
      };

    // Optimize for push.apply( _, NodeList )
    try {
      push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
      );
      // Support: Android&lt;4.0
      // Detect silently failing push.apply
      arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
      push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
          push_native.apply( target, slice.call(els) );
        } :

        // Support: IE&lt;9
        // Otherwise append directly
        function( target, els ) {
          var j = target.length,
            i = 0;
          // Can&#x27;t trust NodeList.length
          while ( (target[j++] = els[i++]) ) {}
          target.length = j - 1;
        }
      };
    }

    /**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *  deleting the oldest entry
     */

    function select( selector, context, results, seed ) {
      var i, tokens, token, type, find,
        match = tokenize( selector );

      if ( !seed ) {
        // Try to minimize operations if there is only one group
        if ( match.length === 1 ) {

          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice( 0 );
          if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
              support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
              Expr.relative[ tokens[1].type ] ) {

            context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, 
              funescape), context ) || [] )[0];
            if ( !context ) {
              return results;
            }
            selector = selector.slice( tokens.shift().value.length );
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
          while ( i-- ) {
            token = tokens[i];

            // Abort if we hit a combinator
            if ( Expr.relative[ (type = token.type) ] ) {
              break;
            }
            if ( (find = Expr.find[ type ]) ) {
              // Search, expanding context for leading sibling combinators
              if ( (seed = find(
                token.matches[0].replace( runescape, funescape ),
                rsibling.test( tokens[0].type ) &amp;&amp; context.parentNode || context
              )) ) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice( i, 1 );
                selector = seed.length &amp;&amp; toSelector( tokens );
                if ( !selector ) {
                  push.apply( results, seed );
                  return results;
                }

                break;
              }
            }
          }
        }
      }

      // Compile and execute a filtering function
      // Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
      compile( selector, match )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector )
      );
      return results;
    }

    function Sizzle( selector, context, results, seed ) {
      var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

      if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
      }

      context = context || document;
      results = results || [];

      if ( !selector || typeof selector !== &quot;string&quot; ) {
        return results;
      }

      if ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {
        return [];
      }

      if ( documentIsHTML &amp;&amp; !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
          // Speed-up: Sizzle(&quot;#ID&quot;)
          if ( (m = match[1]) ) {
            if ( nodeType === 9 ) {
              elem = context.getElementById( m );
              // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963
              if ( elem &amp;&amp; elem.parentNode ) {
                // Handle the case where IE, Opera, and Webkit return items
                // by name instead of ID
                if ( elem.id === m ) {
                  results.push( elem );
                  return results;
                }
              } else {
                return results;
              }
            } else {
              // Context is not a document
              if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
                contains( context, elem ) &amp;&amp; elem.id === m ) {
                results.push( elem );
                return results;
              }
            }

          // Speed-up: Sizzle(&quot;TAG&quot;)
          } else if ( match[2] ) {
            push.apply( results, context.getElementsByTagName( selector ) );
            return results;

          // Speed-up: Sizzle(&quot;.CLASS&quot;)
          } else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName ) {
            push.apply( results, context.getElementsByClassName( m ) );
            return results;
          }
        }

        // QSA path
        if ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 &amp;&amp; selector;

          // qSA works strangely on Element-rooted queries
          // We can work around this by specifying an extra ID on the root
          // and working up from there (Thanks to Andrew Dupont for the technique)
          // IE 8 doesn&#x27;t work on object elements
          if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
            groups = tokenize( selector );

            if ( (old = context.getAttribute(&quot;id&quot;)) ) {
              nid = old.replace( rescape, &quot;\\$&amp;&quot; );
            } else {
              context.setAttribute( &quot;id&quot;, nid );
            }
            nid = &quot;[id=&#x27;&quot; + nid + &quot;&#x27;] &quot;;

            i = groups.length;
            while ( i-- ) {
              groups[i] = nid + toSelector( groups[i] );
            }
            newContext = rsibling.test( selector ) &amp;&amp; context.parentNode || context;
            newSelector = groups.join(&quot;,&quot;);
          }

          if ( newSelector ) {
            try {
              push.apply( results,
                newContext.querySelectorAll( newSelector )
              );
              return results;
            } catch(qsaError) {
            } finally {
              if ( !old ) {
                context.removeAttribute(&quot;id&quot;);
              }
            }
          }
        }
      }

      // All others
      return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
    }

    function createCache () {
      var keys = [];

      function cache( key, value ) {
        // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key += &quot; &quot; ) &gt; Expr.cacheLength ) {
          // Only keep the most recent entries
          delete cache[ keys.shift() ];
        }
        return (cache[ key ] = value);
      }
      return cache;
    }


    classCache = createCache();
    tokenCache = createCache();
    compilerCache = createCache();

    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction( fn ) {
      fn[ expando ] = true;
      return fn;
    }

    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */
    function assert( fn ) {
      var div = document.createElement(&quot;div&quot;);

      try {
        return !!fn( div );
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
          div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
      }
    }

    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle( attrs, handler ) {
      var arr = attrs.split(&quot;|&quot;),
        i = attrs.length;

      while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
      }
    }

    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck( a, b ) {
      var cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
          ( ~b.sourceIndex || MAX_NEGATIVE ) -
          ( ~a.sourceIndex || MAX_NEGATIVE );

      // Use IE sourceIndex if available on both nodes
      if ( diff ) {
        return diff;
      }

      // Check if b follows a
      if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
          if ( cur === b ) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }

    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo( type ) {
      return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === &quot;input&quot; &amp;&amp; elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo( type ) {
      return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
      };
    }

    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo( fn ) {
      return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
          var j,
            matchIndexes = fn( [], seed.length, argument ),
            i = matchIndexes.length;

          // Match elements found at the specified indexes
          while ( i-- ) {
            if ( seed[ (j = matchIndexes[i]) ] ) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }

    /**
     * Detect xml
     * @param {Element|Object} elem An element or a document
     */
    isXML = Sizzle.isXML = function( elem ) {
      // documentElement is verified for cases where it doesn&#x27;t yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
    };

    // Expose support vars for convenience
    support = Sizzle.support = {};

    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function( node ) {
      var doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

      // If no document and documentElement is available, return
      if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
      }

      // Set our document
      document = doc;
      docElem = doc.documentElement;

      // Support tests
      documentIsHTML = !isXML( doc );

      // Support: IE&gt;8
      // If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,
      // IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936
      // IE6-8 do not support the defaultView property so parent will be undefined
      if ( parent &amp;&amp; parent.attachEvent &amp;&amp; parent !== parent.top ) {
        parent.attachEvent( &quot;onbeforeunload&quot;, function() {
          setDocument();
        });
      }

      /* Attributes
      ---------------------------------------------------------------------- */

      // Support: IE&lt;8
      // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
      support.attributes = assert(function( div ) {
        div.className = &quot;i&quot;;
        return !div.getAttribute(&quot;className&quot;);
      });

      /* getElement(s)By*
      ---------------------------------------------------------------------- */

      // Check if getElementsByTagName(&quot;*&quot;) returns only elements
      support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment(&quot;&quot;) );
        return !div.getElementsByTagName(&quot;*&quot;).length;
      });

      // Check if getElementsByClassName can be trusted
      support.getElementsByClassName = assert(function( div ) {
        div.innerHTML = &quot;&lt;div class=&#x27;a&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;a i&#x27;&gt;&lt;/div&gt;&quot;;

        // Support: Safari&lt;4
        // Catch class over-caching
        div.firstChild.className = &quot;i&quot;;
        // Support: Opera&lt;10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName(&quot;i&quot;).length === 2;
      });

      // Support: IE&lt;10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don&#x27;t pick up programatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
      });

      // ID find and filter
      if ( support.getById ) {
        Expr.find[&quot;ID&quot;] = function( id, context ) {
          if ( typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML ) {
            var m = context.getElementById( id );
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            return m &amp;&amp; m.parentNode ? [m] : [];
          }
        };
        Expr.filter[&quot;ID&quot;] = function( id ) {
          var attrId = id.replace( runescape, funescape );
          return function( elem ) {
            return elem.getAttribute(&quot;id&quot;) === attrId;
          };
        };
      } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find[&quot;ID&quot;];

        Expr.filter[&quot;ID&quot;] =  function( id ) {
          var attrId = id.replace( runescape, funescape );
          return function( elem ) {
            var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
            return node &amp;&amp; node.value === attrId;
          };
        };
      }

      // Tag
      Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
        function( tag, context ) {
          if ( typeof context.getElementsByTagName !== strundefined ) {
            return context.getElementsByTagName( tag );
          }
        } :
        function( tag, context ) {
          var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName( tag );

          // Filter out possible comments
          if ( tag === &quot;*&quot; ) {
            while ( (elem = results[i++]) ) {
              if ( elem.nodeType === 1 ) {
                tmp.push( elem );
              }
            }

            return tmp;
          }
          return results;
        };

      // Class
      Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML ) {
          return context.getElementsByClassName( className );
        }
      };

      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */

      // QSA and matchesSelector support

      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];

      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever &#x60;document.activeElement&#x60; is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See http://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];

      if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
          // Select is set to empty string on purpose
          // This is to test IE&#x27;s treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // http://bugs.jquery.com/ticket/12359
          div.innerHTML = &quot;&lt;select&gt;&lt;option selected=&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

          // Support: IE8
          // Boolean attributes and &quot;value&quot; are not treated correctly
          if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
            rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
          }

          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
            rbuggyQSA.push(&quot;:checked&quot;);
          }
        });

        assert(function( div ) {

          // Support: Opera 10-12/IE8
          // ^= $= *= and empty values
          // Should not select anything
          // Support: Windows 8 Native Apps
          // The type attribute is restricted during .innerHTML assignment
          var input = doc.createElement(&quot;input&quot;);
          input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
          div.appendChild( input ).setAttribute( &quot;t&quot;, &quot;&quot; );

          if ( div.querySelectorAll(&quot;[t^=&#x27;&#x27;]&quot;).length ) {
            rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&#x27;&#x27;|\&quot;\&quot;)&quot; );
          }

          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
            rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
          }

          // Opera 10-11 does not throw on post-comma invalid pseudos
          div.querySelectorAll(&quot;*,:x&quot;);
          rbuggyQSA.push(&quot;,.*:&quot;);
        });
      }

      if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
          // Check to see if it&#x27;s possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call( div, &quot;div&quot; );

          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call( div, &quot;[s!=&#x27;&#x27;]:x&quot; );
          rbuggyMatches.push( &quot;!=&quot;, pseudos );
        });
      }

      rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
      rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

      /* Contains
      ---------------------------------------------------------------------- */

      // Element contains another
      // Purposefully does not implement inclusive descendent
      // As in, an element does not contain itself
      contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
        function( a, b ) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
          return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
            adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
          ));
        } :
        function( a, b ) {
          if ( b ) {
            while ( (b = b.parentNode) ) {
              if ( b === a ) {
                return true;
              }
            }
          }
          return false;
        };

      /* Sorting
      ---------------------------------------------------------------------- */

      // Document order sorting
      sortOrder = docElem.compareDocumentPosition ?
      function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
          hasDuplicate = true;
          return 0;
        }

        var compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( b );

        if ( compare ) {
          // Disconnected nodes
          if ( compare &amp; 1 ||
            (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {

            // Choose the first element that is related to our preferred document
            if ( a === doc || contains(preferredDoc, a) ) {
              return -1;
            }
            if ( b === doc || contains(preferredDoc, b) ) {
              return 1;
            }

            // Maintain original order
            return sortInput ?
              ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
              0;
          }

          return compare &amp; 4 ? -1 : 1;
        }

        // Not directly comparable, sort on existence of method
        return a.compareDocumentPosition ? -1 : 1;
      } :
      function( a, b ) {
        var cur,
          i = 0,
          aup = a.parentNode,
          bup = b.parentNode,
          ap = [ a ],
          bp = [ b ];

        // Exit early if the nodes are identical
        if ( a === b ) {
          hasDuplicate = true;
          return 0;

        // Parentless nodes are either documents or disconnected
        } else if ( !aup || !bup ) {
          return a === doc ? -1 :
            b === doc ? 1 :
            aup ? -1 :
            bup ? 1 :
            sortInput ?
            ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
            0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
          return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
          ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
          bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
          i++;
        }

        return i ?
          // Do a sibling check if the nodes have a common ancestor
          siblingCheck( ap[i], bp[i] ) :

          // Otherwise nodes in our document sort first
          ap[i] === preferredDoc ? -1 :
          bp[i] === preferredDoc ? 1 :
          0;
      };

      return doc;
    };

    // Sizzle.matches = function( expr, elements ) {
    //   return Sizzle( expr, null, null, elements );
    // };

    Sizzle.matchesSelector = function( elem, expr ) {
      // Set document vars if needed
      if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
      }

      // Make sure that attribute selectors are quoted
      expr = expr.replace( rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot; );

      if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
          var ret = matches.call( elem, expr );

          // IE 9&#x27;s matchesSelector returns false on disconnected nodes
          if ( ret || support.disconnectedMatch ||
              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
            return ret;
          }
        } catch(e) {}
      }

      return Sizzle( expr, document, null, [elem] ).length &gt; 0;
    };

    Sizzle.contains = function( context, elem ) {
      // Set document vars if needed
      if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
      }
      return contains( context, elem );
    };

    Sizzle.attr = function( elem, name ) {
      // Set document vars if needed
      if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
      }

      var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don&#x27;t get fooled by Object.prototype properties (jQuery #13807)
        val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
          fn( elem, name, !documentIsHTML ) :
          undefined;

      return val === undefined ?
        support.attributes || !documentIsHTML ?
          elem.getAttribute( name ) :
          (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            null :
        val;
    };

    Sizzle.error = function( msg ) {
      throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
    };

    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function( results ) {
      var elem,
        duplicates = [],
        j = 0,
        i = 0;

      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
      results.sort( sortOrder );

      if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
          if ( elem === results[ i ] ) {
            j = duplicates.push( i );
          }
        }
        while ( j-- ) {
          results.splice( duplicates[ j ], 1 );
        }
      }

      return results;
    };

    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function( elem ) {
      var node,
        ret = &quot;&quot;,
        i = 0,
        nodeType = elem.nodeType;

      if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        for ( ; (node = elem[i]); i++ ) {
          // Do not traverse comment nodes
          ret += getText( node );
        }
      } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (see #11153)
        if ( typeof elem.textContent === &quot;string&quot; ) {
          return elem.textContent;
        } else {
          // Traverse its children
          for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
            ret += getText( elem );
          }
        }
      } else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes

      return ret;
    };

    Expr = Sizzle.selectors = {

      // Can be adjusted by the user
      cacheLength: 50,

      createPseudo: markFunction,

      match: matchExpr,

      attrHandle: {},

      find: {},

      relative: {
        &quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
        &quot; &quot;: { dir: &quot;parentNode&quot; },
        &quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
        &quot;~&quot;: { dir: &quot;previousSibling&quot; }
      },

      preFilter: {
        &quot;ATTR&quot;: function( match ) {
          match[1] = match[1].replace( runescape, funescape );

          // Move the given value to match[3] whether quoted or unquoted
          match[3] = ( match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

          if ( match[2] === &quot;~=&quot; ) {
            match[3] = &quot; &quot; + match[3] + &quot; &quot;;
          }

          return match.slice( 0, 4 );
        },

        &quot;CHILD&quot;: function( match ) {
          /* matches from matchExpr[&quot;CHILD&quot;]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
            // nth-* requires argument
            if ( !match[3] ) {
              Sizzle.error( match[0] );
            }

            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
            match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );

          // other types prohibit arguments
          } else if ( match[3] ) {
            Sizzle.error( match[0] );
          }

          return match;
        },

        &quot;PSEUDO&quot;: function( match ) {
          var excess,
            unquoted = !match[5] &amp;&amp; match[2];

          if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
            return null;
          }

          // Accept quoted arguments as-is
          if ( match[3] &amp;&amp; match[4] !== undefined ) {
            match[2] = match[4];

          // Strip excess characters from unquoted arguments
          } else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
            // Get excess from tokenize (recursively)
            (excess = tokenize( unquoted, true )) &amp;&amp;
            // advance to the next closing parenthesis
            (excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

            // excess is a negative index
            match[0] = match[0].slice( 0, excess );
            match[2] = unquoted.slice( 0, excess );
          }

          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice( 0, 3 );
        }
      },

      filter: {

        &quot;TAG&quot;: function( nodeNameSelector ) {
          var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
          return nodeNameSelector === &quot;*&quot; ?
            function() { return true; } :
            function( elem ) {
              return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
            };
        },

        &quot;CLASS&quot;: function( className ) {
          var pattern = classCache[ className + &quot; &quot; ];

          return pattern ||
            (pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
            classCache( className, function( elem ) {
              return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
            });
        },

        &quot;ATTR&quot;: function( name, operator, check ) {
          return function( elem ) {
            var result = Sizzle.attr( elem, name );

            if ( result == null ) {
              return operator === &quot;!=&quot;;
            }
            if ( !operator ) {
              return true;
            }

            result += &quot;&quot;;

            return operator === &quot;=&quot; ? result === check :
              operator === &quot;!=&quot; ? result !== check :
              operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
              operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
              operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
              operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
              operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
              false;
          };
        },

        &quot;CHILD&quot;: function( type, what, argument, first, last ) {
          var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
            forward = type.slice( -4 ) !== &quot;last&quot;,
            ofType = what === &quot;of-type&quot;;

          return first === 1 &amp;&amp; last === 0 ?

            // Shortcut for :nth-*(n)
            function( elem ) {
              return !!elem.parentNode;
            } :

            function( elem, context, xml ) {
              var cache, outerCache, node, diff, nodeIndex, start,
                dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
                parent = elem.parentNode,
                name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                useCache = !xml &amp;&amp; !ofType;

              if ( parent ) {

                // :(first|last|only)-(child|of-type)
                if ( simple ) {
                  while ( dir ) {
                    node = elem;
                    while ( (node = node[ dir ]) ) {
                      if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                        return false;
                      }
                    }
                    // Reverse direction for :only-* (if we haven&#x27;t yet done so)
                    start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
                  }
                  return true;
                }

                start = [ forward ? parent.firstChild : parent.lastChild ];

                // non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
                if ( forward &amp;&amp; useCache ) {
                  // Seek &#x60;elem&#x60; from a previously-cached index
                  outerCache = parent[ expando ] || (parent[ expando ] = {});
                  cache = outerCache[ type ] || [];
                  nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
                  diff = cache[0] === dirruns &amp;&amp; cache[2];
                  node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

                  while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

                    // Fallback to seeking &#x60;elem&#x60; from the start
                    (diff = nodeIndex = 0) || start.pop()) ) {

                    // When found, cache indexes on &#x60;parent&#x60; and break
                    if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
                      outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                      break;
                    }
                  }

                // Use previously-cached element index if available
                } else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {
                  diff = cache[1];

                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                } else {
                  // Use the same loop as above to seek &#x60;elem&#x60; from the start
                  while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
                    (diff = nodeIndex = 0) || start.pop()) ) {

                    if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {
                      // Cache the index of each encountered element
                      if ( useCache ) {
                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                      }

                      if ( node === elem ) {
                        break;
                      }
                    }
                  }
                }

                // Incorporate the offset, then check against cycle size
                diff -= last;
                return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
              }
            };
        },

        &quot;PSEUDO&quot;: function( pseudo, argument ) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that SetFilters inherits from pseudos
          var args,
            fn = Expr.pseudos[ pseudo ] || Expr.SetFilters[ pseudo.toLowerCase() ] ||
              Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if ( fn[ expando ] ) {
            return fn( argument );
          }

          // But maintain support for old signatures
          if ( fn.length &gt; 1 ) {
            args = [ pseudo, pseudo, &quot;&quot;, argument ];
            return Expr.SetFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
              markFunction(function( seed, matches ) {
                var idx,
                  matched = fn( seed, argument ),
                  i = matched.length;
                while ( i-- ) {
                  idx = indexOf.call( seed, matched[i] );
                  seed[ idx ] = !( matches[ idx ] = matched[i] );
                }
              }) :
              function( elem ) {
                return fn( elem, 0, args );
              };
          }

          return fn;
        }
      },

      pseudos: {
        // Potentially complex pseudos
        &quot;not&quot;: markFunction(function( selector ) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
            results = [],
            matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

          return matcher[ expando ] ?
            markFunction(function( seed, matches, context, xml ) {
              var elem,
                unmatched = matcher( seed, null, xml, [] ),
                i = seed.length;

              // Match elements unmatched by &#x60;matcher&#x60;
              while ( i-- ) {
                if ( (elem = unmatched[i]) ) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) :
            function( elem, context, xml ) {
              input[0] = elem;
              matcher( input, null, xml, results );
              return !results.pop();
            };
        }),

        &quot;has&quot;: markFunction(function( selector ) {
          return function( elem ) {
            return Sizzle( selector, elem ).length &gt; 0;
          };
        }),

        &quot;contains&quot;: markFunction(function( text ) {
          return function( elem ) {
            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
          };
        }),

        // &quot;Whether an element is represented by a :lang() selector
        // is based solely on the element&#x27;s language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by &quot;-&quot;.
        // The matching of C against the element&#x27;s language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name.&quot;
        // http://www.w3.org/TR/selectors/#lang-pseudo
        &quot;lang&quot;: markFunction( function( lang ) {
          // lang value must be a valid identifier
          if ( !ridentifier.test(lang || &quot;&quot;) ) {
            Sizzle.error( &quot;unsupported lang: &quot; + lang );
          }
          lang = lang.replace( runescape, funescape ).toLowerCase();
          return function( elem ) {
            var elemLang;
            do {
              if ( (elemLang = documentIsHTML ?
                elem.lang :
                elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {

                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
              }
            } while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
            return false;
          };
        }),

        // Miscellaneous
        &quot;target&quot;: function( elem ) {
          var hash = win.location &amp;&amp; win.location.hash;
          return hash &amp;&amp; hash.slice( 1 ) === elem.id;
        },

        &quot;root&quot;: function( elem ) {
          return elem === docElem;
        },

        &quot;focus&quot;: function( elem ) {
          return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        &quot;enabled&quot;: function( elem ) {
          return elem.disabled === false;
        },

        &quot;disabled&quot;: function( elem ) {
          return elem.disabled === true;
        },

        &quot;checked&quot;: function( elem ) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
        },

        &quot;selected&quot;: function( elem ) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if ( elem.parentNode ) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },

        // Contents
        &quot;empty&quot;: function( elem ) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
          //   not comment, processing instructions, or others
          // Thanks to Diego Perini for the nodeName shortcut
          //   Greater than &quot;@&quot; means alpha characters (specifically not starting with &quot;#&quot; or &quot;?&quot;)
          for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
            if ( elem.nodeName &gt; &quot;@&quot; || elem.nodeType === 3 || elem.nodeType === 4 ) {
              return false;
            }
          }
          return true;
        },

        &quot;parent&quot;: function( elem ) {
          return !Expr.pseudos[&quot;empty&quot;]( elem );
        },

        // Element/input types
        &quot;header&quot;: function( elem ) {
          return rheader.test( elem.nodeName );
        },

        &quot;input&quot;: function( elem ) {
          return rinputs.test( elem.nodeName );
        },

        &quot;button&quot;: function( elem ) {
          var name = elem.nodeName.toLowerCase();
          return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
        },

        &quot;text&quot;: function( elem ) {
          var attr;
          // IE6 and 7 will map elem.type to &#x27;text&#x27; for new HTML5 types (search, etc)
          // use getAttribute instead to test this case
          return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
            elem.type === &quot;text&quot; &amp;&amp;
            ( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === elem.type );
        },

        // Position-in-collection
        &quot;first&quot;: createPositionalPseudo(function() {
          return [ 0 ];
        }),

        &quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
          return [ length - 1 ];
        }),

        &quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
          return [ argument &lt; 0 ? argument + length : argument ];
        }),

        &quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
          var i = 0;
          for ( ; i &lt; length; i += 2 ) {
            matchIndexes.push( i );
          }
          return matchIndexes;
        }),

        &quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
          var i = 1;
          for ( ; i &lt; length; i += 2 ) {
            matchIndexes.push( i );
          }
          return matchIndexes;
        }),

        &quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
          var i = argument &lt; 0 ? argument + length : argument;
          for ( ; --i &gt;= 0; ) {
            matchIndexes.push( i );
          }
          return matchIndexes;
        }),

        &quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
          var i = argument &lt; 0 ? argument + length : argument;
          for ( ; ++i &lt; length; ) {
            matchIndexes.push( i );
          }
          return matchIndexes;
        })
      }
    };

    Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

    // Add button/input type pseudos
    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
      Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
      Expr.pseudos[ i ] = createButtonPseudo( i );
    }

    // Easy API for creating new SetFilters
    function SetFilters() {}
    SetFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.SetFilters = new SetFilters();

    function tokenize( selector, parseOnly ) {
      var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + &quot; &quot; ];

      if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
          if ( match ) {
            // Don&#x27;t consume trailing commas as valid
            soFar = soFar.slice( match[0].length ) || soFar;
          }
          groups.push( tokens = [] );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace( rtrim, &quot; &quot; )
          });
          soFar = soFar.slice( matched.length );
        }

        // Filters
        for ( type in Expr.filter ) {
          if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
            (match = preFilters[ type ]( match ))) ) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice( matched.length );
          }
        }

        if ( !matched ) {
          break;
        }
      }

      // Return the length of the invalid excess
      // if we&#x27;re just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ?
        soFar.length :
        soFar ?
          Sizzle.error( selector ) :
          // Cache the tokens
          tokenCache( selector, groups ).slice( 0 );
    }

    function toSelector( tokens ) {
      var i = 0,
        len = tokens.length,
        selector = &quot;&quot;;
      for ( ; i &lt; len; i++ ) {
        selector += tokens[i].value;
      }
      return selector;
    }

    function addCombinator( matcher, combinator, base ) {
      var dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
        doneName = done++;

      return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
          while ( (elem = elem[ dir ]) ) {
            if ( elem.nodeType === 1 || checkNonElements ) {
              return matcher( elem, context, xml );
            }
          }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
          var data, cache, outerCache,
            dirkey = dirruns + &quot; &quot; + doneName;

          // We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from dir caching
          if ( xml ) {
            while ( (elem = elem[ dir ]) ) {
              if ( elem.nodeType === 1 || checkNonElements ) {
                if ( matcher( elem, context, xml ) ) {
                  return true;
                }
              }
            }
          } else {
            while ( (elem = elem[ dir ]) ) {
              if ( elem.nodeType === 1 || checkNonElements ) {
                outerCache = elem[ expando ] || (elem[ expando ] = {});
                if ( (cache = outerCache[ dir ]) &amp;&amp; cache[0] === dirkey ) {
                  if ( (data = cache[1]) === true || data === cachedruns ) {
                    return data === true;
                  }
                } else {
                  cache = outerCache[ dir ] = [ dirkey ];
                  cache[1] = matcher( elem, context, xml ) || cachedruns;
                  if ( cache[1] === true ) {
                    return true;
                  }
                }
              }
            }
          }
        };
    }

    function elementMatcher( matchers ) {
      return matchers.length &gt; 1 ?
        function( elem, context, xml ) {
          var i = matchers.length;
          while ( i-- ) {
            if ( !matchers[i]( elem, context, xml ) ) {
              return false;
            }
          }
          return true;
        } :
        matchers[0];
    }

    function condense( unmatched, map, filter, context, xml ) {
      var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

      for ( ; i &lt; len; i++ ) {
        if ( (elem = unmatched[i]) ) {
          if ( !filter || filter( elem, context, xml ) ) {
            newUnmatched.push( elem );
            if ( mapped ) {
              map.push( i );
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
      if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
      }
      if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
      }
      return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,

          // Get initial elements from seed or context
          elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
            condense( elems, preMap, preFilter, context, xml ) :
            elems,

          matcherOut = matcher ?
            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

              // ...intermediate processing is necessary
              [] :

              // ...otherwise use results directly
              results :
            matcherIn;

        // Find primary matches
        if ( matcher ) {
          matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
          temp = condense( matcherOut, postMap );
          postFilter( temp, [], context, xml );

          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while ( i-- ) {
            if ( (elem = temp[i]) ) {
              matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
            }
          }
        }

        if ( seed ) {
          if ( postFinder || preFilter ) {
            if ( postFinder ) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while ( i-- ) {
                if ( (elem = matcherOut[i]) ) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push( (matcherIn[i] = elem) );
                }
              }
              postFinder( null, (matcherOut = []), temp, xml );
            }

            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while ( i-- ) {
              if ( (elem = matcherOut[i]) &amp;&amp;
                (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {

                seed[temp] = !(results[temp] = elem);
              }
            }
          }

        // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(
            matcherOut === results ?
              matcherOut.splice( preexisting, matcherOut.length ) :
              matcherOut
          );
          if ( postFinder ) {
            postFinder( null, results, matcherOut, xml );
          } else {
            push.apply( results, matcherOut );
          }
        }
      });
    }

    function matcherFromTokens( tokens ) {
      var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
          return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
          return indexOf.call( checkContext, elem ) &gt; -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
          return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
            (checkContext = context).nodeType ?
              matchContext( elem, context, xml ) :
              matchAnyContext( elem, context, xml ) );
        } ];

      for ( ; i &lt; len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
          matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
          matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

          // Return special upon seeing a positional matcher
          if ( matcher[ expando ] ) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for ( ; j &lt; len; j++ ) {
              if ( Expr.relative[ tokens[j].type ] ) {
                break;
              }
            }
            return setMatcher(
              i &gt; 1 &amp;&amp; elementMatcher( matchers ),
              i &gt; 1 &amp;&amp; toSelector(
                // If the preceding token was a descendant combinator, insert an implicit any-element &#x60;*&#x60;
                tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
              ).replace( rtrim, &quot;$1&quot; ),
              matcher,
              i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
              j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
              j &lt; len &amp;&amp; toSelector( tokens )
            );
          }
          matchers.push( matcher );
        }
      }

      return elementMatcher( matchers );
    }

    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
      // A counter to specify which element is currently being matched
      var matcherCachedRuns = 0,
        bySet = setMatchers.length &gt; 0,
        byElement = elementMatchers.length &gt; 0,
        superMatcher = function( seed, context, xml, results, expandContext ) {
          var elem, j, matcher,
            setMatched = [],
            matchedCount = 0,
            i = &quot;0&quot;,
            unmatched = seed &amp;&amp; [],
            outermost = expandContext != null,
            contextBackup = outermostContext,
            // We must always have either seed elements or context
            elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, expandContext &amp;&amp; context.parentNode || context ),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
            len = elems.length;

          if ( outermost ) {
            outermostContext = context !== document &amp;&amp; context;
            cachedruns = matcherCachedRuns;
          }

          // Add elements passing elementMatchers directly to results
          // Keep &#x60;i&#x60; a string if there are no elements so &#x60;matchedCount&#x60; will be &quot;00&quot; below
          // Support: IE&lt;9, Safari
          // Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
          for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
            if ( byElement &amp;&amp; elem ) {
              j = 0;
              while ( (matcher = elementMatchers[j++]) ) {
                if ( matcher( elem, context, xml ) ) {
                  results.push( elem );
                  break;
                }
              }
              if ( outermost ) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }

            // Track unmatched elements for set filters
            if ( bySet ) {
              // They will have gone through all possible matchers
              if ( (elem = !matcher &amp;&amp; elem) ) {
                matchedCount--;
              }

              // Lengthen the array for every element, matched or not
              if ( seed ) {
                unmatched.push( elem );
              }
            }
          }

          // Apply set filters to unmatched elements
          matchedCount += i;
          if ( bySet &amp;&amp; i !== matchedCount ) {
            j = 0;
            while ( (matcher = setMatchers[j++]) ) {
              matcher( unmatched, setMatched, context, xml );
            }

            if ( seed ) {
              // Reintegrate element matches to eliminate the need for sorting
              if ( matchedCount &gt; 0 ) {
                while ( i-- ) {
                  if ( !(unmatched[i] || setMatched[i]) ) {
                    setMatched[i] = pop.call( results );
                  }
                }
              }

              // Discard index placeholder values to get only actual matches
              setMatched = condense( setMatched );
            }

            // Add matches to results
            push.apply( results, setMatched );

            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
              ( matchedCount + setMatchers.length ) &gt; 1 ) {

              Sizzle.uniqueSort( results );
            }
          }

          // Override manipulation of globals by nested matchers
          if ( outermost ) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

      return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
    }

    compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
      var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + &quot; &quot; ];

      if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !group ) {
          group = tokenize( selector );
        }
        i = group.length;
        while ( i-- ) {
          cached = matcherFromTokens( group[i] );
          if ( cached[ expando ] ) {
            setMatchers.push( cached );
          } else {
            elementMatchers.push( cached );
          }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
      }
      return cached;
    };

    function multipleContexts( selector, contexts, results ) {
      var i = 0,
        len = contexts.length;
      for ( ; i &lt; len; i++ ) {
        Sizzle( selector, contexts[i], results );
      }
      return results;
    }

    // One-time assignments

    // Sort stability
    support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;

    // Support: Chrome&lt;14
    // Always assume duplicates if they aren&#x27;t passed to the comparison function
    support.detectDuplicates = hasDuplicate;

    // Initialize against the default document
    setDocument();

    // Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function( div1 ) {
      // Should return 1, but returns 4 (following)
      return div1.compareDocumentPosition( document.createElement(&quot;div&quot;) ) &amp; 1;
    });

    // Support: IE&lt;8
    // Prevent attribute/property &quot;interpolation&quot;
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if ( !assert(function( div ) {
      div.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
      return div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
    }) ) {
      addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
        if ( !isXML ) {
          return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
        }
      });
    }

    // Support: IE&lt;9
    // Use defaultValue in place of getAttribute(&quot;value&quot;)
    if ( !support.attributes || !assert(function( div ) {
      div.innerHTML = &quot;&lt;input/&gt;&quot;;
      div.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
      return div.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
    }) ) {
      addHandle( &quot;value&quot;, function( elem, name, isXML ) {
        if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
          return elem.defaultValue;
        }
      });
    }

    // Support: IE&lt;9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if ( !assert(function( div ) {
      return div.getAttribute(&quot;disabled&quot;) == null;
    }) ) {
      addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
          return (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
            val.value :
            elem[ name ] === true ? name.toLowerCase() : null;
        }
      });
    }

    // document.querySelectorAll = function querySelectorAll (selector) {
    //   return Sizzle(selector, this);
    // };

    // document.querySelector = function querySelector (selector) {
    //   return (document.querySelectorAll.call(this, selector)[0] || null);
    // };

    return Sizzle;

  }());
</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
