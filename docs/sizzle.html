<!DOCTYPE html>

<html>
<head>
  <title>sizzle.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="ajax.html">
                ajax.js
              </a>
            
              
              <a class="source" href="anim.html">
                anim.js
              </a>
            
              
              <a class="source" href="core.html">
                core.js
              </a>
            
              
              <a class="source" href="detect.html">
                detect.js
              </a>
            
              
              <a class="source" href="dom.html">
                dom.js
              </a>
            
              
              <a class="source" href="end.html">
                end.js
              </a>
            
              
              <a class="source" href="evt.html">
                evt.js
              </a>
            
              
              <a class="source" href="fx.html">
                fx.js
              </a>
            
              
              <a class="source" href="legacy.html">
                legacy.js
              </a>
            
              
              <a class="source" href="misc.html">
                misc.js
              </a>
            
              
              <a class="source" href="more.html">
                more.js
              </a>
            
              
              <a class="source" href="polyfill.html">
                polyfill.js
              </a>
            
              
              <a class="source" href="sizzle.html">
                sizzle.js
              </a>
            
              
              <a class="source" href="start.html">
                start.js
              </a>
            
              
              <a class="source" href="test.html">
                test.js
              </a>
            
              
              <a class="source" href="util.html">
                util.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sizzle.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>querySelector pollyfill using Sizzle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> sizzle = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">if</span> (feature.qsa3 === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">/*!
     * Sizzle CSS Selector Engine v1.10.6-pre
     * http://sizzlejs.com/
     *
     * Copyright 2013 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     */</span>

    <span class="hljs-keyword">var</span> i,
      support,
      cachedruns = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> keys = [];

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span> <span class="hljs-params">(key, value)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Use (key + “ “) to avoid collision 
with native prototype properties (see Issue #157)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (keys.push(key += <span class="hljs-string">" "</span>) &gt; Expr.cacheLength) {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Only keep the most recent entries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">delete</span> cache[keys.shift()];
          }
          <span class="hljs-keyword">return</span> (cache[key] = value);
        }
        <span class="hljs-keyword">return</span> cache;
      },
      Expr,
      getText,
      isXML,
      compile,
      outermostContext,
      sortInput,</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Local document vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      setDocument,
      <span class="hljs-built_in">document</span>,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Instance-specific data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expando = <span class="hljs-string">"sizzle"</span> + -(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()),
      preferredDoc = win.document,
      dirruns = <span class="hljs-number">0</span>,
      done = <span class="hljs-number">0</span>,
      classCache,
      tokenCache,
      compilerCache,
      hasDuplicate = <span class="hljs-literal">false</span>,
      sortOrder = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">if</span> (a === b) {
          hasDuplicate = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>General-purpose constants</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      strundefined = <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>,
      MAX_NEGATIVE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Instance methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      hasOwn = ({}).hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Use a stripped-down indexOf if we can’t use a native one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      indexOf = arr.indexOf || <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
          len = <span class="hljs-keyword">this</span>.length;

        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] === elem) {
            <span class="hljs-keyword">return</span> i;
          }
        }

        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
      },

      booleans = <span class="hljs-string">"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Regular expressions</p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Whitespace characters <a href="http://www.w3.org/TR/css3-selectors/#whitespace">http://www.w3.org/TR/css3-selectors/#whitespace</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      whitespace = <span class="hljs-string">"[\\x20\\t\\r\\n\\f]"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><a href="http://www.w3.org/TR/css3-syntax/#characters">http://www.w3.org/TR/css3-syntax/#characters</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      characterEncoding = <span class="hljs-string">"(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Loosely modeled on CSS identifier characters
An unquoted value should be a CSS identifier 
<a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">http://www.w3.org/TR/css3-selectors/#attribute-selectors</a>
Proper syntax: 
<a href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      identifier = characterEncoding.replace(<span class="hljs-string">"w"</span>, <span class="hljs-string">"w#"</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Acceptable operators 
<a href="http://www.w3.org/TR/selectors/#attribute-selectors">http://www.w3.org/TR/selectors/#attribute-selectors</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      attributes = <span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*("</span> + characterEncoding + <span class="hljs-string">")"</span> + 
        whitespace +
        <span class="hljs-string">"*(?:([*^$|!~]?=)"</span> + whitespace + 
        <span class="hljs-string">"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("</span> + identifier + <span class="hljs-string">")|)|)"</span> + 
        whitespace + <span class="hljs-string">"*\\]"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Prefer arguments quoted,
  then not containing pseudos/brackets,
  then attribute selectors/non-parenthetical expressions,
  then anything else
These preferences are here to reduce the number of selectors
  needing tokenize in the PSEUDO preFilter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      pseudos = <span class="hljs-string">":("</span> + characterEncoding + 
        <span class="hljs-string">")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"</span> + 
        attributes.replace(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>) + <span class="hljs-string">")*)|.*)\\)|)"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rtrim = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"+|((?:^|[^\\\\])(?:\\\\.)*)"</span> + 
        whitespace + <span class="hljs-string">"+$"</span>, <span class="hljs-string">"g"</span>),

      rcomma = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*,"</span> + whitespace + <span class="hljs-string">"*"</span>),
      rcombinators = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*([&gt;+~]|"</span> + whitespace +
        <span class="hljs-string">")"</span> + whitespace + <span class="hljs-string">"*"</span>),

      rsibling = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(whitespace + <span class="hljs-string">"*[+~]"</span>),
      rattributeQuotes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"="</span> + whitespace + <span class="hljs-string">"*([^\\]'\"]*)"</span> + 
        whitespace + <span class="hljs-string">"*\\]"</span>, <span class="hljs-string">"g"</span>),

      rpseudo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pseudos ),
      ridentifier = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + identifier + <span class="hljs-string">"$"</span> ),

      matchExpr = {
        <span class="hljs-string">"ID"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^#("</span> + characterEncoding + <span class="hljs-string">")"</span> ),
        <span class="hljs-string">"CLASS"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^\\.("</span> + characterEncoding + <span class="hljs-string">")"</span> ),
        <span class="hljs-string">"TAG"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^("</span> + characterEncoding.replace(<span class="hljs-string">"w"</span>, <span class="hljs-string">"w*"</span> ) + <span class="hljs-string">")"</span> ),
        <span class="hljs-string">"ATTR"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + attributes ),
        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + pseudos ),
        <span class="hljs-string">"CHILD"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("</span> + whitespace +
          <span class="hljs-string">"*(even|odd|(([+-]|)(\\d*)n|)"</span> + whitespace + <span class="hljs-string">"*(?:([+-]|)"</span> + whitespace +
          <span class="hljs-string">"*(\\d+)|))"</span> + whitespace + <span class="hljs-string">"*\\)|)"</span>, <span class="hljs-string">"i"</span> ),
        <span class="hljs-string">"bool"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^(?:"</span> + booleans + <span class="hljs-string">")$"</span>, <span class="hljs-string">"i"</span> ),</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>For use in libraries implementing .is()
We use this for POS matching in <code>select</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"needsContext"</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^"</span> + whitespace + <span class="hljs-string">"*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("</span> +
          whitespace + <span class="hljs-string">"*((?:-\\d)?\\d*)"</span> + whitespace + <span class="hljs-string">"*\\)|)(?=[^-]|$)"</span>, <span class="hljs-string">"i"</span> )
      },

      rnative = <span class="hljs-regexp">/^[^{]+\{\s*\[native \w/</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Easily-parseable/retrievable ID or TAG or CLASS selectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rquickExpr = <span class="hljs-regexp">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span>,

      rinputs = <span class="hljs-regexp">/^(?:input|select|textarea|button)$/i</span>,
      rheader = <span class="hljs-regexp">/^h\d$/i</span>,

      rescape = <span class="hljs-regexp">/'|\\/g</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>CSS escapes <a href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      runescape = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"\\\\([\\da-f]{1,6}"</span> + whitespace + <span class="hljs-string">"?|("</span> + 
        whitespace + <span class="hljs-string">")|.)"</span>, <span class="hljs-string">"ig"</span> ),
      
      funescape = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, escaped, escapedWhitespace)</span> </span>{
        <span class="hljs-keyword">var</span> high = <span class="hljs-string">"0x"</span> + escaped - <span class="hljs-number">0x10000</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>NaN means non-codepoint
Support: Firefox
Workaround erroneous numeric interpretation of +”0x”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> high !== high || escapedWhitespace ?
          escaped :</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>BMP codepoint</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          high &lt; <span class="hljs-number">0</span> ?
            <span class="hljs-built_in">String</span>.fromCharCode(high + <span class="hljs-number">0x10000</span>) :</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Supplemental Plane codepoint (surrogate pair)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">String</span>.fromCharCode(high &gt;&gt; <span class="hljs-number">10</span> | <span class="hljs-number">0xD800</span>, high &amp; <span class="hljs-number">0x3FF</span> | <span class="hljs-number">0xDC00</span>);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Optimize for push.apply(_, NodeList)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">try</span> {
      push.apply(
        (arr = slice.call(preferredDoc.childNodes)),
        preferredDoc.childNodes
     );</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Support: Android&lt;4.0
Detect silently failing push.apply</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      arr[preferredDoc.childNodes.length].nodeType;
    } <span class="hljs-keyword">catch</span> (e) {
      push = { apply: arr.length ?</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Leverage slice if possible</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(target, els)</span> </span>{
          push_native.apply(target, slice.call(els));
        } :</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Otherwise append directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(target, els)</span> </span>{
          <span class="hljs-keyword">var</span> j = target.length,
            i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Can’t trust NodeList.length</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">while</span> ((target[j++] = els[i++])) {}
          target.length = j - <span class="hljs-number">1</span>;
        }
      };
    }

    <span class="hljs-comment">/**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *  deleting the oldest entry
     */</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">select</span><span class="hljs-params">(selector, context, results, seed)</span> </span>{
      <span class="hljs-keyword">var</span> i, tokens, token, type, find,
        match = tokenize(selector);

      <span class="hljs-keyword">if</span> (!seed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Try to minimize operations if there is only one group</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (match.length === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Take a shortcut and set the context if the root selector is an ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tokens = match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>);
          <span class="hljs-keyword">if</span> (tokens.length &gt; <span class="hljs-number">2</span> &amp;&amp; (token = tokens[<span class="hljs-number">0</span>]).type === <span class="hljs-string">"ID"</span> &amp;&amp;
              support.getById &amp;&amp; context.nodeType === <span class="hljs-number">9</span> &amp;&amp; documentIsHTML &amp;&amp;
              Expr.relative[tokens[<span class="hljs-number">1</span>].type]) {

            context = (Expr.find[<span class="hljs-string">"ID"</span>](token.matches[<span class="hljs-number">0</span>].replace(runescape, 
              funescape), context) || [])[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (!context) {
              <span class="hljs-keyword">return</span> results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Fetch a seed set for right-to-left matching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          i = matchExpr[<span class="hljs-string">"needsContext"</span>].test(selector) ? <span class="hljs-number">0</span> : tokens.length;
          <span class="hljs-keyword">while</span> (i--) {
            token = tokens[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Abort if we hit a combinator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (Expr.relative[(type = token.type)]) {
              <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">if</span> ((find = Expr.find[type])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Search, expanding context for leading sibling combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ((seed = find(
                token.matches[<span class="hljs-number">0</span>].replace(runescape, funescape),
                rsibling.test(tokens[<span class="hljs-number">0</span>].type) &amp;&amp; context.parentNode || context
             ))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>If seed is empty or no tokens remain, we can return early</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                tokens.splice(i, <span class="hljs-number">1</span>);
                selector = seed.length &amp;&amp; toSelector(tokens);
                <span class="hljs-keyword">if</span> (!selector) {
                  push.apply(results, seed);
                  <span class="hljs-keyword">return</span> results;
                }

                <span class="hljs-keyword">break</span>;
              }
            }
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Compile and execute a filtering function
Provide <code>match</code> to avoid retokenization if we modified the selector above</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      compile(selector, match)(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test(selector)
     );
      <span class="hljs-keyword">return</span> results;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sizzle</span><span class="hljs-params">(selector, context, results, seed)</span> </span>{
      <span class="hljs-keyword">var</span> match, elem, m, nodeType,</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>QSA vars</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        i, groups, old, nid, newContext, newSelector;

      <span class="hljs-keyword">if</span> ((context ? context.ownerDocument || context : preferredDoc) !== <span class="hljs-built_in">document</span>) {
        setDocument(context);
      }

      context = context || <span class="hljs-built_in">document</span>;
      results = results || [];

      <span class="hljs-keyword">if</span> (!selector || <span class="hljs-keyword">typeof</span> selector !== <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">return</span> results;
      }

      <span class="hljs-keyword">if</span> ((nodeType = context.nodeType) !== <span class="hljs-number">1</span> &amp;&amp; nodeType !== <span class="hljs-number">9</span>) {
        <span class="hljs-keyword">return</span> [];
      }

      <span class="hljs-keyword">if</span> (documentIsHTML &amp;&amp; !seed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Shortcuts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((match = rquickExpr.exec(selector))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(“#ID”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> ((m = match[<span class="hljs-number">1</span>])) {
            <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">9</span>) {
              elem = context.getElementById(m);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document #6963</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (elem &amp;&amp; elem.parentNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Handle the case where IE, Opera, and Webkit return items
by name instead of ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (elem.id === m) {
                  results.push(elem);
                  <span class="hljs-keyword">return</span> results;
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> results;
              }
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Context is not a document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById(m)) &amp;&amp;
                contains(context, elem) &amp;&amp; elem.id === m) {
                results.push(elem);
                <span class="hljs-keyword">return</span> results;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(“TAG”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>]) {
            push.apply(results, context.getElementsByTagName(selector));
            <span class="hljs-keyword">return</span> results;</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Speed-up: Sizzle(“.CLASS”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((m = match[<span class="hljs-number">3</span>]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            <span class="hljs-keyword">return</span> results;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>QSA path</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === <span class="hljs-number">9</span> &amp;&amp; selector;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>qSA works strangely on Element-rooted queries
We can work around this by specifying an extra ID on the root
and working up from there (Thanks to Andrew Dupont for the technique)
IE 8 doesn’t work on object elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">1</span> &amp;&amp; context.nodeName.toLowerCase() !== <span class="hljs-string">"object"</span>) {
            groups = tokenize(selector);

            <span class="hljs-keyword">if</span> ((old = context.getAttribute(<span class="hljs-string">"id"</span>))) {
              nid = old.replace(rescape, <span class="hljs-string">"\\$&amp;"</span>);
            } <span class="hljs-keyword">else</span> {
              context.setAttribute(<span class="hljs-string">"id"</span>, nid);
            }
            nid = <span class="hljs-string">"[id='"</span> + nid + <span class="hljs-string">"'] "</span>;

            i = groups.length;
            <span class="hljs-keyword">while</span> (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) &amp;&amp; context.parentNode || context;
            newSelector = groups.join(<span class="hljs-string">","</span>);
          }

          <span class="hljs-keyword">if</span> (newSelector) {
            <span class="hljs-keyword">try</span> {
              push.apply(results,
                newContext.querySelectorAll(newSelector)
             );
              <span class="hljs-keyword">return</span> results;
            } <span class="hljs-keyword">catch</span>(qsaError) {
            } <span class="hljs-keyword">finally</span> {
              <span class="hljs-keyword">if</span> (!old) {
                context.removeAttribute(<span class="hljs-string">"id"</span>);
              }
            }
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>All others</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> select(selector.replace(rtrim, <span class="hljs-string">"$1"</span>), context, results, seed);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> keys = [];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cache</span><span class="hljs-params">(key, value)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Use (key + “ “) to avoid collision with native prototype properties (see Issue #157)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (keys.push(key += <span class="hljs-string">" "</span>) &gt; Expr.cacheLength) {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Only keep the most recent entries</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">delete</span> cache[keys.shift()];
        }
        <span class="hljs-keyword">return</span> (cache[key] = value);
      }
      <span class="hljs-keyword">return</span> cache;
    }


    classCache = createCache();
    tokenCache = createCache();
    compilerCache = createCache();

    <span class="hljs-comment">/**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markFunction</span><span class="hljs-params">(fn)</span> </span>{
      fn[expando] = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> fn;
    }

    <span class="hljs-comment">/**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span><span class="hljs-params">(fn)</span> </span>{
      <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> !!fn(div);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">finally</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Remove from its parent by default</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (div.parentNode) {
          div.parentNode.removeChild(div);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>release memory in IE</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        div = <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-comment">/**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addHandle</span><span class="hljs-params">(attrs, handler)</span> </span>{
      <span class="hljs-keyword">var</span> arr = attrs.split(<span class="hljs-string">"|"</span>),
        i = attrs.length;

      <span class="hljs-keyword">while</span> (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }

    <span class="hljs-comment">/**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siblingCheck</span><span class="hljs-params">(a, b)</span> </span>{
      <span class="hljs-keyword">var</span> cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === <span class="hljs-number">1</span> &amp;&amp; b.nodeType === <span class="hljs-number">1</span> &amp;&amp;
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Use IE sourceIndex if available on both nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (diff) {
        <span class="hljs-keyword">return</span> diff;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Check if b follows a</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (cur) {
        <span class="hljs-keyword">while</span> ((cur = cur.nextSibling)) {
          <span class="hljs-keyword">if</span> (cur === b) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
          }
        }
      }

      <span class="hljs-keyword">return</span> a ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInputPseudo</span><span class="hljs-params">(type)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
        <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
        <span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === type;
      };
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createButtonPseudo</span><span class="hljs-params">(type)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
        <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
        <span class="hljs-keyword">return</span> (name === <span class="hljs-string">"input"</span> || name === <span class="hljs-string">"button"</span>) &amp;&amp; elem.type === type;
      };
    }

    <span class="hljs-comment">/**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPositionalPseudo</span><span class="hljs-params">(fn)</span> </span>{
      <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(argument)</span> </span>{
        argument = +argument;
        <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seed, matches)</span> </span>{
          <span class="hljs-keyword">var</span> j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Match elements found at the specified indexes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }

    <span class="hljs-comment">/**
     * Detect xml
     * @param {Element|Object} elem An element or a document
     */</span>
    isXML = Sizzle.isXML = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>documentElement is verified for cases where it doesn’t yet exist
(such as loading iframes in IE - #4833)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
      <span class="hljs-keyword">return</span> documentElement ? documentElement.nodeName !== <span class="hljs-string">"HTML"</span> : <span class="hljs-literal">false</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Expose support vars for convenience</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support = Sizzle.support = {};

    <span class="hljs-comment">/**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */</span>
    setDocument = Sizzle.setDocument = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">var</span> doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>If no document and documentElement is available, return</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (doc === <span class="hljs-built_in">document</span> || doc.nodeType !== <span class="hljs-number">9</span> || !doc.documentElement) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Set our document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-built_in">document</span> = doc;
      docElem = doc.documentElement;</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Support tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      documentIsHTML = !isXML(doc);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Support: IE&gt;8
If iframe document is assigned to “document” variable and if iframe has been reloaded,
IE will throw “permission denied” error when accessing “document” variable, see jQuery #13936
IE6-8 do not support the defaultView property so parent will be undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (parent &amp;&amp; parent.attachEvent &amp;&amp; parent !== parent.top) {
        parent.attachEvent(<span class="hljs-string">"onbeforeunload"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          setDocument();
        });
      }

      <span class="hljs-comment">/* Attributes
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Support: IE&lt;8
Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.attributes = assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
        div.className = <span class="hljs-string">"i"</span>;
        <span class="hljs-keyword">return</span> !div.getAttribute(<span class="hljs-string">"className"</span>);
      });

      <span class="hljs-comment">/* getElement(s)By*
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Check if getElementsByTagName(“*”) returns only elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getElementsByTagName = assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
        div.appendChild(doc.createComment(<span class="hljs-string">""</span>));
        <span class="hljs-keyword">return</span> !div.getElementsByTagName(<span class="hljs-string">"*"</span>).length;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Check if getElementsByClassName can be trusted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getElementsByClassName = assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
        div.innerHTML = <span class="hljs-string">"&lt;div class='a'&gt;&lt;/div&gt;&lt;div class='a i'&gt;&lt;/div&gt;"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Support: Safari&lt;4
Catch class over-caching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        div.firstChild.className = <span class="hljs-string">"i"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Support: Opera&lt;10
Catch gEBCN failure to find non-leading classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> div.getElementsByClassName(<span class="hljs-string">"i"</span>).length === <span class="hljs-number">2</span>;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Support: IE&lt;10
Check if getElementById returns elements by name
The broken getElementById methods don’t pick up programatically-set names,
so use a roundabout getElementsByName test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      support.getById = assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
        docElem.appendChild(div).id = expando;
        <span class="hljs-keyword">return</span> !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>ID find and filter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (support.getById) {
        Expr.find[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id, context)</span> </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.getElementById !== strundefined &amp;&amp; documentIsHTML) {
            <span class="hljs-keyword">var</span> m = context.getElementById(id);</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Check parentNode to catch when Blackberry 4.6 returns
nodes that are no longer in the document #6963</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> m &amp;&amp; m.parentNode ? [m] : [];
          }
        };
        Expr.filter[<span class="hljs-string">"ID"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> </span>{
          <span class="hljs-keyword">var</span> attrId = id.replace(runescape, funescape);
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">return</span> elem.getAttribute(<span class="hljs-string">"id"</span>) === attrId;
          };
        };
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Support: IE6/7
getElementById is not reliable as a find shortcut</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">delete</span> Expr.find[<span class="hljs-string">"ID"</span>];

        Expr.filter[<span class="hljs-string">"ID"</span>] =  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> </span>{
          <span class="hljs-keyword">var</span> attrId = id.replace(runescape, funescape);
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">typeof</span> elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(<span class="hljs-string">"id"</span>);
            <span class="hljs-keyword">return</span> node &amp;&amp; node.value === attrId;
          };
        };
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Expr.find[<span class="hljs-string">"TAG"</span>] = support.getElementsByTagName ?
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tag, context)</span> </span>{
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.getElementsByTagName !== strundefined) {
            <span class="hljs-keyword">return</span> context.getElementsByTagName(tag);
          }
        } :
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tag, context)</span> </span>{
          <span class="hljs-keyword">var</span> elem,
            tmp = [],
            i = <span class="hljs-number">0</span>,
            results = context.getElementsByTagName(tag);</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Filter out possible comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">"*"</span>) {
            <span class="hljs-keyword">while</span> ((elem = results[i++])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span>) {
                tmp.push(elem);
              }
            }

            <span class="hljs-keyword">return</span> tmp;
          }
          <span class="hljs-keyword">return</span> results;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Class</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      Expr.find[<span class="hljs-string">"CLASS"</span>] = support.getElementsByClassName &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(className, context)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML) {
          <span class="hljs-keyword">return</span> context.getElementsByClassName(className);
        }
      };

      <span class="hljs-comment">/* QSA/matchesSelector
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>QSA and matchesSelector support</p>

            </div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>matchesSelector(:active) reports false when true (IE9/Opera 11.5)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rbuggyMatches = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>qSa(:focus) reports false when true (Chrome 21)
We allow this because of a bug in IE8/9 that throws an error
whenever <code>document.activeElement</code> is accessed on an iframe
So, we allow :focus to pass through QSA all the time to avoid the IE error
See <a href="http://bugs.jquery.com/ticket/13378">http://bugs.jquery.com/ticket/13378</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rbuggyQSA = [];

      <span class="hljs-keyword">if</span> ((support.qsa = rnative.test(doc.querySelectorAll))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Build QSA regex
Regex strategy adopted from Diego Perini</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Select is set to empty string on purpose
This is to test IE’s treatment of not explicitly
setting a boolean content attribute,
since its presence should be enough
<a href="http://bugs.jquery.com/ticket/12359">http://bugs.jquery.com/ticket/12359</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          div.innerHTML = <span class="hljs-string">"&lt;select&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Support: IE8
Boolean attributes and “value” are not treated correctly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">"[selected]"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">"\\["</span> + whitespace + <span class="hljs-string">"*(?:value|"</span> + booleans + <span class="hljs-string">")"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Webkit/Opera - :checked should return selected option elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a>
IE8 throws error here and will not see later tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">":checked"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">":checked"</span>);
          }
        });

        assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Support: Opera 10-12/IE8
^= $= *= and empty values
Should not select anything
Support: Windows 8 Native Apps
The type attribute is restricted during .innerHTML assignment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> input = doc.createElement(<span class="hljs-string">"input"</span>);
          input.setAttribute(<span class="hljs-string">"type"</span>, <span class="hljs-string">"hidden"</span>);
          div.appendChild(input).setAttribute(<span class="hljs-string">"t"</span>, <span class="hljs-string">""</span>);

          <span class="hljs-keyword">if</span> (div.querySelectorAll(<span class="hljs-string">"[t^='']"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">"[*^$]="</span> + whitespace + <span class="hljs-string">"*(?:''|\"\")"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
IE8 throws error here and will not see later tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!div.querySelectorAll(<span class="hljs-string">":enabled"</span>).length) {
            rbuggyQSA.push(<span class="hljs-string">":enabled"</span>, <span class="hljs-string">":disabled"</span>);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Opera 10-11 does not throw on post-comma invalid pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          div.querySelectorAll(<span class="hljs-string">"*,:x"</span>);
          rbuggyQSA.push(<span class="hljs-string">",.*:"</span>);
        });
      }

      <span class="hljs-keyword">if</span> ((support.matchesSelector = rnative.test((matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector)))) {

        assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Check to see if it’s possible to do matchesSelector
on a disconnected node (IE 9)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          support.disconnectedMatch = matches.call(div, <span class="hljs-string">"div"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>This should fail with an exception
Gecko does not error, returns false instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matches.call(div, <span class="hljs-string">"[s!='']:x"</span>);
          rbuggyMatches.push(<span class="hljs-string">"!="</span>, pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(rbuggyQSA.join(<span class="hljs-string">"|"</span>));
      rbuggyMatches = rbuggyMatches.length &amp;&amp; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(rbuggyMatches.join(<span class="hljs-string">"|"</span>));

      <span class="hljs-comment">/* Contains
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Element contains another
Purposefully does not implement inclusive descendent
As in, an element does not contain itself</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ?
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
          <span class="hljs-keyword">var</span> adown = a.nodeType === <span class="hljs-number">9</span> ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
          <span class="hljs-keyword">return</span> a === bup || !!(bup &amp;&amp; bup.nodeType === <span class="hljs-number">1</span> &amp;&amp; (
            adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; <span class="hljs-number">16</span>
         ));
        } :
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
          <span class="hljs-keyword">if</span> (b) {
            <span class="hljs-keyword">while</span> ((b = b.parentNode)) {
              <span class="hljs-keyword">if</span> (b === a) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        };

      <span class="hljs-comment">/* Sorting
      ---------------------------------------------------------------------- */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Document order sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      sortOrder = docElem.compareDocumentPosition ?
      <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Flag for duplicate removal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (a === b) {
          hasDuplicate = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">var</span> compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(b);

        <span class="hljs-keyword">if</span> (compare) {</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Disconnected nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (compare &amp; <span class="hljs-number">1</span> ||
            (!support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Choose the first element that is related to our preferred document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (a === doc || contains(preferredDoc, a)) {
              <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">if</span> (b === doc || contains(preferredDoc, b)) {
              <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Maintain original order</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> sortInput ?
              (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
              <span class="hljs-number">0</span>;
          }

          <span class="hljs-keyword">return</span> compare &amp; <span class="hljs-number">4</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Not directly comparable, sort on existence of method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> a.compareDocumentPosition ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
      } :
      <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
        <span class="hljs-keyword">var</span> cur,
          i = <span class="hljs-number">0</span>,
          aup = a.parentNode,
          bup = b.parentNode,
          ap = [a],
          bp = [b];</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Exit early if the nodes are identical</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (a === b) {
          hasDuplicate = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Parentless nodes are either documents or disconnected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!aup || !bup) {
          <span class="hljs-keyword">return</span> a === doc ? -<span class="hljs-number">1</span> :
            b === doc ? <span class="hljs-number">1</span> :
            aup ? -<span class="hljs-number">1</span> :
            bup ? <span class="hljs-number">1</span> :
            sortInput ?
            (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
            <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>If the nodes are siblings, we can do a quick check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aup === bup) {
          <span class="hljs-keyword">return</span> siblingCheck(a, b);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Otherwise we need full lists of their ancestors for comparison</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cur = a;
        <span class="hljs-keyword">while</span> ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        <span class="hljs-keyword">while</span> ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Walk down the tree looking for a discrepancy</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (ap[i] === bp[i]) {
          i++;
        }

        <span class="hljs-keyword">return</span> i ?</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Do a sibling check if the nodes have a common ancestor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          siblingCheck(ap[i], bp[i]) :</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Otherwise nodes in our document sort first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ap[i] === preferredDoc ? -<span class="hljs-number">1</span> :
          bp[i] === preferredDoc ? <span class="hljs-number">1</span> :
          <span class="hljs-number">0</span>;
      };

      <span class="hljs-keyword">return</span> doc;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Sizzle.matches = function(expr, elements) {
  return Sizzle(expr, null, null, elements);
};</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    Sizzle.matchesSelector = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, expr)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((elem.ownerDocument || elem) !== <span class="hljs-built_in">document</span>) {
        setDocument(elem);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Make sure that attribute selectors are quoted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      expr = expr.replace(rattributeQuotes, <span class="hljs-string">"='$1']"</span>);

      <span class="hljs-keyword">if</span> (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp;
        (!rbuggyQSA     || !rbuggyQSA.test(expr))) {

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> ret = matches.call(elem, expr);</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>IE 9’s matchesSelector returns false on disconnected nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (ret || support.disconnectedMatch ||</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>As well, disconnected nodes are said to be in a document
fragment in IE 9</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              elem.document &amp;&amp; elem.document.nodeType !== <span class="hljs-number">11</span>) {
            <span class="hljs-keyword">return</span> ret;
          }
        } <span class="hljs-keyword">catch</span>(e) {}
      }

      <span class="hljs-keyword">return</span> Sizzle(expr, <span class="hljs-built_in">document</span>, <span class="hljs-literal">null</span>, [elem]).length &gt; <span class="hljs-number">0</span>;
    };

    Sizzle.contains = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(context, elem)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((context.ownerDocument || context) !== <span class="hljs-built_in">document</span>) {
        setDocument(context);
      }
      <span class="hljs-keyword">return</span> contains(context, elem);
    };

    Sizzle.attr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, name)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Set document vars if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((elem.ownerDocument || elem) !== <span class="hljs-built_in">document</span>) {
        setDocument(elem);
      }

      <span class="hljs-keyword">var</span> fn = Expr.attrHandle[name.toLowerCase()],</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Don’t get fooled by Object.prototype properties (jQuery #13807)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span> ?
        support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            <span class="hljs-literal">null</span> :
        val;
    };

    Sizzle.error = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg)</span> </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Syntax error, unrecognized expression: "</span> + msg);
    };

    <span class="hljs-comment">/**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */</span>
    Sizzle.uniqueSort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(results)</span> </span>{
      <span class="hljs-keyword">var</span> elem,
        duplicates = [],
        j = <span class="hljs-number">0</span>,
        i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Unless we <em>know</em> we can detect duplicates, assume their presence</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable &amp;&amp; results.slice(<span class="hljs-number">0</span>);
      results.sort(sortOrder);

      <span class="hljs-keyword">if</span> (hasDuplicate) {
        <span class="hljs-keyword">while</span> ((elem = results[i++])) {
          <span class="hljs-keyword">if</span> (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        <span class="hljs-keyword">while</span> (j--) {
          results.splice(duplicates[j], <span class="hljs-number">1</span>);
        }
      }

      <span class="hljs-keyword">return</span> results;
    };

    <span class="hljs-comment">/**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */</span>
    getText = Sizzle.getText = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
      <span class="hljs-keyword">var</span> node,
        ret = <span class="hljs-string">""</span>,
        i = <span class="hljs-number">0</span>,
        nodeType = elem.nodeType;

      <span class="hljs-keyword">if</span> (!nodeType) {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>If no nodeType, this is expected to be an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (; (node = elem[i]); i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Do not traverse comment nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ret += getText(node);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">1</span> || nodeType === <span class="hljs-number">9</span> || nodeType === <span class="hljs-number">11</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Use textContent for elements
innerText usage removed for consistency of new lines (see #11153)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> elem.textContent === <span class="hljs-string">"string"</span>) {
          <span class="hljs-keyword">return</span> elem.textContent;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Traverse its children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">3</span> || nodeType === <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span> elem.nodeValue;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Do not include comment or processing instruction nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">return</span> ret;
    };

    Expr = Sizzle.selectors = {</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Can be adjusted by the user</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      cacheLength: <span class="hljs-number">50</span>,

      createPseudo: markFunction,

      match: matchExpr,

      attrHandle: {},

      find: {},

      relative: {
        <span class="hljs-string">"&gt;"</span>: { dir: <span class="hljs-string">"parentNode"</span>, first: <span class="hljs-literal">true</span> },
        <span class="hljs-string">" "</span>: { dir: <span class="hljs-string">"parentNode"</span> },
        <span class="hljs-string">"+"</span>: { dir: <span class="hljs-string">"previousSibling"</span>, first: <span class="hljs-literal">true</span> },
        <span class="hljs-string">"~"</span>: { dir: <span class="hljs-string">"previousSibling"</span> }
      },

      preFilter: {
        <span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(match)</span> </span>{
          match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].replace(runescape, funescape);</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Move the given value to match[3] whether quoted or unquoted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          match[<span class="hljs-number">3</span>] = (match[<span class="hljs-number">4</span>] || match[<span class="hljs-number">5</span>] || <span class="hljs-string">""</span>).replace(runescape, funescape);

          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">2</span>] === <span class="hljs-string">"~="</span>) {
            match[<span class="hljs-number">3</span>] = <span class="hljs-string">" "</span> + match[<span class="hljs-number">3</span>] + <span class="hljs-string">" "</span>;
          }

          <span class="hljs-keyword">return</span> match.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
        },

        <span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(match)</span> </span>{
          <span class="hljs-comment">/* matches from matchExpr["CHILD"]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
          */</span>
          match[<span class="hljs-number">1</span>] = match[<span class="hljs-number">1</span>].toLowerCase();

          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">1</span>].slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) === <span class="hljs-string">"nth"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>nth-* requires argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!match[<span class="hljs-number">3</span>]) {
              Sizzle.error(match[<span class="hljs-number">0</span>]);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>numeric x and y parameters for Expr.filter.CHILD
remember that false/true cast respectively to 0/1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            match[<span class="hljs-number">4</span>] = +(match[<span class="hljs-number">4</span>] ? match[<span class="hljs-number">5</span>] + (match[<span class="hljs-number">6</span>] || <span class="hljs-number">1</span>) : <span class="hljs-number">2</span> * (match[<span class="hljs-number">3</span>] === <span class="hljs-string">"even"</span> || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span>));
            match[<span class="hljs-number">5</span>] = +((match[<span class="hljs-number">7</span>] + match[<span class="hljs-number">8</span>]) || match[<span class="hljs-number">3</span>] === <span class="hljs-string">"odd"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>other types prohibit arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match[<span class="hljs-number">3</span>]) {
            Sizzle.error(match[<span class="hljs-number">0</span>]);
          }

          <span class="hljs-keyword">return</span> match;
        },

        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(match)</span> </span>{
          <span class="hljs-keyword">var</span> excess,
            unquoted = !match[<span class="hljs-number">5</span>] &amp;&amp; match[<span class="hljs-number">2</span>];

          <span class="hljs-keyword">if</span> (matchExpr[<span class="hljs-string">"CHILD"</span>].test(match[<span class="hljs-number">0</span>])) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Accept quoted arguments as-is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (match[<span class="hljs-number">3</span>] &amp;&amp; match[<span class="hljs-number">4</span>] !== <span class="hljs-literal">undefined</span>) {
            match[<span class="hljs-number">2</span>] = match[<span class="hljs-number">4</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Strip excess characters from unquoted arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Get excess from tokenize (recursively)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (excess = tokenize(unquoted, <span class="hljs-literal">true</span>)) &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>advance to the next closing parenthesis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            (excess = unquoted.indexOf(<span class="hljs-string">")"</span>, unquoted.length - excess) - unquoted.length)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>excess is a negative index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            match[<span class="hljs-number">0</span>] = match[<span class="hljs-number">0</span>].slice(<span class="hljs-number">0</span>, excess);
            match[<span class="hljs-number">2</span>] = unquoted.slice(<span class="hljs-number">0</span>, excess);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Return only captures needed by the pseudo filter method (type and argument)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> match.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
        }
      },

      filter: {

        <span class="hljs-string">"TAG"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nodeNameSelector)</span> </span>{
          <span class="hljs-keyword">var</span> nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          <span class="hljs-keyword">return</span> nodeNameSelector === <span class="hljs-string">"*"</span> ?
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; } :
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
              <span class="hljs-keyword">return</span> elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
            };
        },

        <span class="hljs-string">"CLASS"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(className)</span> </span>{
          <span class="hljs-keyword">var</span> pattern = classCache[className + <span class="hljs-string">" "</span>];

          <span class="hljs-keyword">return</span> pattern ||
            (pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"(^|"</span> + whitespace + <span class="hljs-string">")"</span> + className + <span class="hljs-string">"("</span> + whitespace + <span class="hljs-string">"|$)"</span>)) &amp;&amp;
            classCache(className, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
              <span class="hljs-keyword">return</span> pattern.test(<span class="hljs-keyword">typeof</span> elem.className === <span class="hljs-string">"string"</span> &amp;&amp; elem.className || <span class="hljs-keyword">typeof</span> elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(<span class="hljs-string">"class"</span>) || <span class="hljs-string">""</span>);
            });
        },

        <span class="hljs-string">"ATTR"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, operator, check)</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">var</span> result = Sizzle.attr(elem, name);

            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span> operator === <span class="hljs-string">"!="</span>;
            }
            <span class="hljs-keyword">if</span> (!operator) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            result += <span class="hljs-string">""</span>;

            <span class="hljs-keyword">return</span> operator === <span class="hljs-string">"="</span> ? result === check :
              operator === <span class="hljs-string">"!="</span> ? result !== check :
              operator === <span class="hljs-string">"^="</span> ? check &amp;&amp; result.indexOf(check) === <span class="hljs-number">0</span> :
              operator === <span class="hljs-string">"*="</span> ? check &amp;&amp; result.indexOf(check) &gt; -<span class="hljs-number">1</span> :
              operator === <span class="hljs-string">"$="</span> ? check &amp;&amp; result.slice(-check.length) === check :
              operator === <span class="hljs-string">"~="</span> ? (<span class="hljs-string">" "</span> + result + <span class="hljs-string">" "</span>).indexOf(check) &gt; -<span class="hljs-number">1</span> :
              operator === <span class="hljs-string">"|="</span> ? result === check || result.slice(<span class="hljs-number">0</span>, check.length + <span class="hljs-number">1</span>) === check + <span class="hljs-string">"-"</span> :
              <span class="hljs-literal">false</span>;
          };
        },

        <span class="hljs-string">"CHILD"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, what, argument, first, last)</span> </span>{
          <span class="hljs-keyword">var</span> simple = type.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) !== <span class="hljs-string">"nth"</span>,
            forward = type.slice(-<span class="hljs-number">4</span>) !== <span class="hljs-string">"last"</span>,
            ofType = what === <span class="hljs-string">"of-type"</span>;

          <span class="hljs-keyword">return</span> first === <span class="hljs-number">1</span> &amp;&amp; last === <span class="hljs-number">0</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Shortcut for :nth-*(n)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
              <span class="hljs-keyword">return</span> !!elem.parentNode;
            } :

            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
              <span class="hljs-keyword">var</span> cache, outerCache, node, diff, nodeIndex, start,
                dir = simple !== forward ? <span class="hljs-string">"nextSibling"</span> : <span class="hljs-string">"previousSibling"</span>,
                parent = elem.parentNode,
                name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                useCache = !xml &amp;&amp; !ofType;

              <span class="hljs-keyword">if</span> (parent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>:(first|last|only)-(child|of-type)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (simple) {
                  <span class="hljs-keyword">while</span> (dir) {
                    node = elem;
                    <span class="hljs-keyword">while</span> ((node = node[dir])) {
                      <span class="hljs-keyword">if</span> (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                      }
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>Reverse direction for :only-* (if we haven’t yet done so)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    start = dir = type === <span class="hljs-string">"only"</span> &amp;&amp; !start &amp;&amp; <span class="hljs-string">"nextSibling"</span>;
                  }
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }

                start = [forward ? parent.firstChild : parent.lastChild];</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>non-xml :nth-child(…) stores cache data on <code>parent</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (forward &amp;&amp; useCache) {</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Seek <code>elem</code> from a previously-cached index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  outerCache = parent[expando] || (parent[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">1</span>];
                  diff = cache[<span class="hljs-number">0</span>] === dirruns &amp;&amp; cache[<span class="hljs-number">2</span>];
                  node = nodeIndex &amp;&amp; parent.childNodes[nodeIndex];

                  <span class="hljs-keyword">while</span> ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>Fallback to seeking <code>elem</code> from the start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    (diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop())) {</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>When found, cache indexes on <code>parent</code> and break</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span> &amp;&amp; ++diff &amp;&amp; node === elem) {
                      outerCache[type] = [dirruns, nodeIndex, diff];
                      <span class="hljs-keyword">break</span>;
                    }
                  }</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>Use previously-cached element index if available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (useCache &amp;&amp; (cache = (elem[expando] || (elem[expando] = {}))[type]) &amp;&amp; cache[<span class="hljs-number">0</span>] === dirruns) {
                  diff = cache[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>xml :nth-child(…) or :nth-last-child(…) or :nth(-last)?-of-type(…)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>Use the same loop as above to seek <code>elem</code> from the start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">while</span> ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||
                    (diff = nodeIndex = <span class="hljs-number">0</span>) || start.pop())) {

                    <span class="hljs-keyword">if</span> ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === <span class="hljs-number">1</span>) &amp;&amp; ++diff) {</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Cache the index of each encountered element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                      <span class="hljs-keyword">if</span> (useCache) {
                        (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                      }

                      <span class="hljs-keyword">if</span> (node === elem) {
                        <span class="hljs-keyword">break</span>;
                      }
                    }
                  }
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Incorporate the offset, then check against cycle size</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                diff -= last;
                <span class="hljs-keyword">return</span> diff === first || (diff % first === <span class="hljs-number">0</span> &amp;&amp; diff / first &gt;= <span class="hljs-number">0</span>);
              }
            };
        },

        <span class="hljs-string">"PSEUDO"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pseudo, argument)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>pseudo-class names are case-insensitive
<a href="http://www.w3.org/TR/selectors/#pseudo-classes">http://www.w3.org/TR/selectors/#pseudo-classes</a>
Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
Remember that SetFilters inherits from pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> args,
            fn = Expr.pseudos[pseudo] || Expr.SetFilters[pseudo.toLowerCase()] ||
              Sizzle.error(<span class="hljs-string">"unsupported pseudo: "</span> + pseudo);</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>The user may use createPseudo to indicate that
arguments are needed to create the filter function
just as Sizzle does</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (fn[expando]) {
            <span class="hljs-keyword">return</span> fn(argument);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>But maintain support for old signatures</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (fn.length &gt; <span class="hljs-number">1</span>) {
            args = [pseudo, pseudo, <span class="hljs-string">""</span>, argument];
            <span class="hljs-keyword">return</span> Expr.SetFilters.hasOwnProperty(pseudo.toLowerCase()) ?
              markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seed, matches)</span> </span>{
                <span class="hljs-keyword">var</span> idx,
                  matched = fn(seed, argument),
                  i = matched.length;
                <span class="hljs-keyword">while</span> (i--) {
                  idx = indexOf.call(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) :
              <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
                <span class="hljs-keyword">return</span> fn(elem, <span class="hljs-number">0</span>, args);
              };
          }

          <span class="hljs-keyword">return</span> fn;
        }
      },

      pseudos: {</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Potentially complex pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"not"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(selector)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>Trim the selector passed to compile
to avoid treating leading and trailing
spaces as combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, <span class="hljs-string">"$1"</span>));

          <span class="hljs-keyword">return</span> matcher[expando] ?
            markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seed, matches, context, xml)</span> </span>{
              <span class="hljs-keyword">var</span> elem,
                unmatched = matcher(seed, <span class="hljs-literal">null</span>, xml, []),
                i = seed.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Match elements unmatched by <code>matcher</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> ((elem = unmatched[i])) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) :
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
              input[<span class="hljs-number">0</span>] = elem;
              matcher(input, <span class="hljs-literal">null</span>, xml, results);
              <span class="hljs-keyword">return</span> !results.pop();
            };
        }),

        <span class="hljs-string">"has"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(selector)</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">return</span> Sizzle(selector, elem).length &gt; <span class="hljs-number">0</span>;
          };
        }),

        <span class="hljs-string">"contains"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text)</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">return</span> (elem.textContent || elem.innerText || getText(elem)).indexOf(text) &gt; -<span class="hljs-number">1</span>;
          };
        }),</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>“Whether an element is represented by a :lang() selector
is based solely on the element’s language value
being equal to the identifier C,
or beginning with the identifier C immediately followed by “-“.
The matching of C against the element’s language value is performed case-insensitively.
The identifier C does not have to be a valid language name.”
<a href="http://www.w3.org/TR/selectors/#lang-pseudo">http://www.w3.org/TR/selectors/#lang-pseudo</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"lang"</span>: markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lang)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>lang value must be a valid identifier</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!ridentifier.test(lang || <span class="hljs-string">""</span>)) {
            Sizzle.error(<span class="hljs-string">"unsupported lang: "</span> + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
            <span class="hljs-keyword">var</span> elemLang;
            <span class="hljs-keyword">do</span> {
              <span class="hljs-keyword">if</span> ((elemLang = documentIsHTML ?
                elem.lang :
                elem.getAttribute(<span class="hljs-string">"xml:lang"</span>) || elem.getAttribute(<span class="hljs-string">"lang"</span>))) {

                elemLang = elemLang.toLowerCase();
                <span class="hljs-keyword">return</span> elemLang === lang || elemLang.indexOf(lang + <span class="hljs-string">"-"</span>) === <span class="hljs-number">0</span>;
              }
            } <span class="hljs-keyword">while</span> ((elem = elem.parentNode) &amp;&amp; elem.nodeType === <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          };
        }),</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Miscellaneous</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"target"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">var</span> hash = win.location &amp;&amp; win.location.hash;
          <span class="hljs-keyword">return</span> hash &amp;&amp; hash.slice(<span class="hljs-number">1</span>) === elem.id;
        },

        <span class="hljs-string">"root"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> elem === docElem;
        },

        <span class="hljs-string">"focus"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> elem === <span class="hljs-built_in">document</span>.activeElement &amp;&amp; (!<span class="hljs-built_in">document</span>.hasFocus || <span class="hljs-built_in">document</span>.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>Boolean properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"enabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">false</span>;
        },

        <span class="hljs-string">"disabled"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> elem.disabled === <span class="hljs-literal">true</span>;
        },

        <span class="hljs-string">"checked"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>In CSS3, :checked should return both checked and selected elements
<a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> nodeName = elem.nodeName.toLowerCase();
          <span class="hljs-keyword">return</span> (nodeName === <span class="hljs-string">"input"</span> &amp;&amp; !!elem.checked) || (nodeName === <span class="hljs-string">"option"</span> &amp;&amp; !!elem.selected);
        },

        <span class="hljs-string">"selected"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Accessing this property makes selected-by-default
options in Safari work properly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          <span class="hljs-keyword">return</span> elem.selected === <span class="hljs-literal">true</span>;
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Contents</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"empty"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p><a href="http://www.w3.org/TR/selectors/#empty-pseudo">http://www.w3.org/TR/selectors/#empty-pseudo</a>
:empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
  not comment, processing instructions, or others
Thanks to Diego Perini for the nodeName shortcut
  Greater than “@” means alpha characters (specifically not starting with “#” or “?”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            <span class="hljs-keyword">if</span> (elem.nodeName &gt; <span class="hljs-string">"@"</span> || elem.nodeType === <span class="hljs-number">3</span> || elem.nodeType === <span class="hljs-number">4</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        },

        <span class="hljs-string">"parent"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> !Expr.pseudos[<span class="hljs-string">"empty"</span>](elem);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>Element/input types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"header"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> rheader.test(elem.nodeName);
        },

        <span class="hljs-string">"input"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> rinputs.test(elem.nodeName);
        },

        <span class="hljs-string">"button"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">var</span> name = elem.nodeName.toLowerCase();
          <span class="hljs-keyword">return</span> name === <span class="hljs-string">"input"</span> &amp;&amp; elem.type === <span class="hljs-string">"button"</span> || name === <span class="hljs-string">"button"</span>;
        },

        <span class="hljs-string">"text"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">var</span> attr;</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>IE6 and 7 will map elem.type to ‘text’ for new HTML5 types (search, etc)
use getAttribute instead to test this case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span> &amp;&amp;
            elem.type === <span class="hljs-string">"text"</span> &amp;&amp;
            ((attr = elem.getAttribute(<span class="hljs-string">"type"</span>)) == <span class="hljs-literal">null</span> || attr.toLowerCase() === elem.type);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Position-in-collection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-string">"first"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
          <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>];
        }),

        <span class="hljs-string">"last"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length)</span> </span>{
          <span class="hljs-keyword">return</span> [length - <span class="hljs-number">1</span>];
        }),

        <span class="hljs-string">"eq"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length, argument)</span> </span>{
          <span class="hljs-keyword">return</span> [argument &lt; <span class="hljs-number">0</span> ? argument + length : argument];
        }),

        <span class="hljs-string">"even"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length)</span> </span>{
          <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">for</span> (; i &lt; length; i += <span class="hljs-number">2</span>) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"odd"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length)</span> </span>{
          <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
          <span class="hljs-keyword">for</span> (; i &lt; length; i += <span class="hljs-number">2</span>) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"lt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length, argument)</span> </span>{
          <span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
          <span class="hljs-keyword">for</span> (; --i &gt;= <span class="hljs-number">0</span>;) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        }),

        <span class="hljs-string">"gt"</span>: createPositionalPseudo(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchIndexes, length, argument)</span> </span>{
          <span class="hljs-keyword">var</span> i = argument &lt; <span class="hljs-number">0</span> ? argument + length : argument;
          <span class="hljs-keyword">for</span> (; ++i &lt; length;) {
            matchIndexes.push(i);
          }
          <span class="hljs-keyword">return</span> matchIndexes;
        })
      }
    };

    Expr.pseudos[<span class="hljs-string">"nth"</span>] = Expr.pseudos[<span class="hljs-string">"eq"</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Add button/input type pseudos</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> { radio: <span class="hljs-literal">true</span>, checkbox: <span class="hljs-literal">true</span>, file: <span class="hljs-literal">true</span>, password: <span class="hljs-literal">true</span>, image: <span class="hljs-literal">true</span> }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> { submit: <span class="hljs-literal">true</span>, reset: <span class="hljs-literal">true</span> }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Easy API for creating new SetFilters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SetFilters</span><span class="hljs-params">()</span> </span>{}
    SetFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.SetFilters = <span class="hljs-keyword">new</span> SetFilters();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(selector, parseOnly)</span> </span>{
      <span class="hljs-keyword">var</span> matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[selector + <span class="hljs-string">" "</span>];

      <span class="hljs-keyword">if</span> (cached) {
        <span class="hljs-keyword">return</span> parseOnly ? <span class="hljs-number">0</span> : cached.slice(<span class="hljs-number">0</span>);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      <span class="hljs-keyword">while</span> (soFar) {</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Comma and first run</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!matched || (match = rcomma.exec(soFar))) {
          <span class="hljs-keyword">if</span> (match) {</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>Don’t consume trailing commas as valid</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            soFar = soFar.slice(match[<span class="hljs-number">0</span>].length) || soFar;
          }
          groups.push(tokens = []);
        }

        matched = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>Combinators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>Cast descendant combinators to space</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            type: match[<span class="hljs-number">0</span>].replace(rtrim, <span class="hljs-string">" "</span>)
          });
          soFar = soFar.slice(matched.length);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (type <span class="hljs-keyword">in</span> Expr.filter) {
          <span class="hljs-keyword">if</span> ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] ||
            (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        <span class="hljs-keyword">if</span> (!matched) {
          <span class="hljs-keyword">break</span>;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>Return the length of the invalid excess
if we’re just parsing
Otherwise, throw an error or return tokens</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> parseOnly ?
        soFar.length :
        soFar ?
          Sizzle.error(selector) :</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>Cache the tokens</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          tokenCache(selector, groups).slice(<span class="hljs-number">0</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toSelector</span><span class="hljs-params">(tokens)</span> </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
        len = tokens.length,
        selector = <span class="hljs-string">""</span>;
      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        selector += tokens[i].value;
      }
      <span class="hljs-keyword">return</span> selector;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCombinator</span><span class="hljs-params">(matcher, combinator, base)</span> </span>{
      <span class="hljs-keyword">var</span> dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === <span class="hljs-string">"parentNode"</span>,
        doneName = done++;

      <span class="hljs-keyword">return</span> combinator.first ?</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>Check against closest ancestor/preceding element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
          <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
            <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
              <span class="hljs-keyword">return</span> matcher(elem, context, xml);
            }
          }
        } :</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>Check against all ancestor/preceding elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
          <span class="hljs-keyword">var</span> data, cache, outerCache,
            dirkey = dirruns + <span class="hljs-string">" "</span> + doneName;</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>We can’t set arbitrary data on XML nodes, so they don’t benefit from dir caching</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (xml) {
            <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
                <span class="hljs-keyword">if</span> (matcher(elem, context, xml)) {
                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span> ((elem = elem[dir])) {
              <span class="hljs-keyword">if</span> (elem.nodeType === <span class="hljs-number">1</span> || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                <span class="hljs-keyword">if</span> ((cache = outerCache[dir]) &amp;&amp; cache[<span class="hljs-number">0</span>] === dirkey) {
                  <span class="hljs-keyword">if</span> ((data = cache[<span class="hljs-number">1</span>]) === <span class="hljs-literal">true</span> || data === cachedruns) {
                    <span class="hljs-keyword">return</span> data === <span class="hljs-literal">true</span>;
                  }
                } <span class="hljs-keyword">else</span> {
                  cache = outerCache[dir] = [dirkey];
                  cache[<span class="hljs-number">1</span>] = matcher(elem, context, xml) || cachedruns;
                  <span class="hljs-keyword">if</span> (cache[<span class="hljs-number">1</span>] === <span class="hljs-literal">true</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                  }
                }
              }
            }
          }
        };
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elementMatcher</span><span class="hljs-params">(matchers)</span> </span>{
      <span class="hljs-keyword">return</span> matchers.length &gt; <span class="hljs-number">1</span> ?
        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
          <span class="hljs-keyword">var</span> i = matchers.length;
          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> (!matchers[i](elem, context, xml)) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } :
        matchers[<span class="hljs-number">0</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">condense</span><span class="hljs-params">(unmatched, map, filter, context, xml)</span> </span>{
      <span class="hljs-keyword">var</span> elem,
        newUnmatched = [],
        i = <span class="hljs-number">0</span>,
        len = unmatched.length,
        mapped = map != <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> ((elem = unmatched[i])) {
          <span class="hljs-keyword">if</span> (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            <span class="hljs-keyword">if</span> (mapped) {
              map.push(i);
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> newUnmatched;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMatcher</span><span class="hljs-params">(preFilter, selector, matcher, postFilter, postFinder, postSelector)</span> </span>{
      <span class="hljs-keyword">if</span> (postFilter &amp;&amp; !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      <span class="hljs-keyword">if</span> (postFinder &amp;&amp; !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      <span class="hljs-keyword">return</span> markFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seed, results, context, xml)</span> </span>{
        <span class="hljs-keyword">var</span> temp, i, elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>Get initial elements from seed or context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          elems = seed || multipleContexts(selector || <span class="hljs-string">"*"</span>, context.nodeType ? [context] : context, []),</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>Prefilter to get matcher input, preserving a map for seed-results synchronization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matcherIn = preFilter &amp;&amp; (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,

          matcherOut = matcher ?</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            postFinder || (seed ? preFilter : preexisting || postFilter) ?</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>…intermediate processing is necessary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              [] :</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>…otherwise use results directly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              results :
            matcherIn;</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>Find primary matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>Apply postFilter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>Un-match failing elements by moving them back to matcherIn</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          i = temp.length;
          <span class="hljs-keyword">while</span> (i--) {
            <span class="hljs-keyword">if</span> ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        <span class="hljs-keyword">if</span> (seed) {
          <span class="hljs-keyword">if</span> (postFinder || preFilter) {
            <span class="hljs-keyword">if</span> (postFinder) {</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>Get the final matcherOut by condensing this intermediate into postFinder contexts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              temp = [];
              i = matcherOut.length;
              <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> ((elem = matcherOut[i])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>Restore matcherIn since elem is not yet a final match</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(<span class="hljs-literal">null</span>, (matcherOut = []), temp, xml);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>Move matched elements from seed to results to keep them synchronized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            i = matcherOut.length;
            <span class="hljs-keyword">while</span> (i--) {
              <span class="hljs-keyword">if</span> ((elem = matcherOut[i]) &amp;&amp;
                (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) &gt; -<span class="hljs-number">1</span>) {

                seed[temp] = !(results[temp] = elem);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>Add elements to results, through postFinder if defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> {
          matcherOut = condense(
            matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
         );
          <span class="hljs-keyword">if</span> (postFinder) {
            postFinder(<span class="hljs-literal">null</span>, results, matcherOut, xml);
          } <span class="hljs-keyword">else</span> {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromTokens</span><span class="hljs-params">(tokens)</span> </span>{
      <span class="hljs-keyword">var</span> checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[<span class="hljs-number">0</span>].type],
        implicitRelative = leadingRelative || Expr.relative[<span class="hljs-string">" "</span>],
        i = leadingRelative ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>The foundational matcher ensures that elements are reachable from top-level context(s)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        matchContext = addCombinator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> elem === checkContext;
        }, implicitRelative, <span class="hljs-literal">true</span>),
        matchAnyContext = addCombinator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> </span>{
          <span class="hljs-keyword">return</span> indexOf.call(checkContext, elem) &gt; -<span class="hljs-number">1</span>;
        }, implicitRelative, <span class="hljs-literal">true</span>),
        matchers = [<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, context, xml)</span> </span>{
          <span class="hljs-keyword">return</span> (!leadingRelative &amp;&amp; (xml || context !== outermostContext)) || (
            (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
        }];

      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } <span class="hljs-keyword">else</span> {
          matcher = Expr.filter[tokens[i].type].apply(<span class="hljs-literal">null</span>, tokens[i].matches);</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>Return special upon seeing a positional matcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (matcher[expando]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>Find the next relative operator (if any) for proper handling</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            j = ++i;
            <span class="hljs-keyword">for</span> (; j &lt; len; j++) {
              <span class="hljs-keyword">if</span> (Expr.relative[tokens[j].type]) {
                <span class="hljs-keyword">break</span>;
              }
            }
            <span class="hljs-keyword">return</span> setMatcher(
              i &gt; <span class="hljs-number">1</span> &amp;&amp; elementMatcher(matchers),
              i &gt; <span class="hljs-number">1</span> &amp;&amp; toSelector(</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>If the preceding token was a descendant combinator, insert an implicit any-element <code>*</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                tokens.slice(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>).concat({ value: tokens[i - <span class="hljs-number">2</span>].type === <span class="hljs-string">" "</span> ? <span class="hljs-string">"*"</span> : <span class="hljs-string">""</span> })
             ).replace(rtrim, <span class="hljs-string">"$1"</span>),
              matcher,
              i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)),
              j &lt; len &amp;&amp; matcherFromTokens((tokens = tokens.slice(j))),
              j &lt; len &amp;&amp; toSelector(tokens)
           );
          }
          matchers.push(matcher);
        }
      }

      <span class="hljs-keyword">return</span> elementMatcher(matchers);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matcherFromGroupMatchers</span><span class="hljs-params">(elementMatchers, setMatchers)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>A counter to specify which element is currently being matched</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> matcherCachedRuns = <span class="hljs-number">0</span>,
        bySet = setMatchers.length &gt; <span class="hljs-number">0</span>,
        byElement = elementMatchers.length &gt; <span class="hljs-number">0</span>,
        superMatcher = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seed, context, xml, results, expandContext)</span> </span>{
          <span class="hljs-keyword">var</span> elem, j, matcher,
            setMatched = [],
            matchedCount = <span class="hljs-number">0</span>,
            i = <span class="hljs-string">"0"</span>,
            unmatched = seed &amp;&amp; [],
            outermost = expandContext != <span class="hljs-literal">null</span>,
            contextBackup = outermostContext,</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>We must always have either seed elements or context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            elems = seed || byElement &amp;&amp; Expr.find[<span class="hljs-string">"TAG"</span>](<span class="hljs-string">"*"</span>, expandContext &amp;&amp; context.parentNode || context),</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>Use integer dirruns iff this is the outermost matcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            dirrunsUnique = (dirruns += contextBackup == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.random() || <span class="hljs-number">0.1</span>),
            len = elems.length;

          <span class="hljs-keyword">if</span> (outermost) {
            outermostContext = context !== <span class="hljs-built_in">document</span> &amp;&amp; context;
            cachedruns = matcherCachedRuns;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>Add elements passing elementMatchers directly to results
Keep <code>i</code> a string if there are no elements so <code>matchedCount</code> will be “00” below
Support: IE<9, Safari
Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (; i !== len &amp;&amp; (elem = elems[i]) != <span class="hljs-literal">null</span>; i++) {
            <span class="hljs-keyword">if</span> (byElement &amp;&amp; elem) {
              j = <span class="hljs-number">0</span>;
              <span class="hljs-keyword">while</span> ((matcher = elementMatchers[j++])) {
                <span class="hljs-keyword">if</span> (matcher(elem, context, xml)) {
                  results.push(elem);
                  <span class="hljs-keyword">break</span>;
                }
              }
              <span class="hljs-keyword">if</span> (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>Track unmatched elements for set filters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (bySet) {</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>They will have gone through all possible matchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> ((elem = !matcher &amp;&amp; elem)) {
                matchedCount--;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>Lengthen the array for every element, matched or not</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (seed) {
                unmatched.push(elem);
              }
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>Apply set filters to unmatched elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          matchedCount += i;
          <span class="hljs-keyword">if</span> (bySet &amp;&amp; i !== matchedCount) {
            j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> ((matcher = setMatchers[j++])) {
              matcher(unmatched, setMatched, context, xml);
            }

            <span class="hljs-keyword">if</span> (seed) {</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>Reintegrate element matches to eliminate the need for sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (matchedCount &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">while</span> (i--) {
                  <span class="hljs-keyword">if</span> (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>Discard index placeholder values to get only actual matches</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              setMatched = condense(setMatched);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>Add matches to results</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            push.apply(results, setMatched);</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>Seedless set matches succeeding multiple successful matchers stipulate sorting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; <span class="hljs-number">0</span> &amp;&amp;
              (matchedCount + setMatchers.length) &gt; <span class="hljs-number">1</span>) {

              Sizzle.uniqueSort(results);
            }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>Override manipulation of globals by nested matchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          <span class="hljs-keyword">return</span> unmatched;
        };

      <span class="hljs-keyword">return</span> bySet ?
        markFunction(superMatcher) :
        superMatcher;
    }

    compile = Sizzle.compile = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(selector, group <span class="hljs-comment">/* Internal Use Only */</span>)</span> </span>{
      <span class="hljs-keyword">var</span> i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + <span class="hljs-string">" "</span>];

      <span class="hljs-keyword">if</span> (!cached) {</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>Generate a function of recursive functions that can be used to check each element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        <span class="hljs-keyword">while</span> (i--) {
          cached = matcherFromTokens(group[i]);
          <span class="hljs-keyword">if</span> (cached[expando]) {
            setMatchers.push(cached);
          } <span class="hljs-keyword">else</span> {
            elementMatchers.push(cached);
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>Cache the compiled function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      <span class="hljs-keyword">return</span> cached;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multipleContexts</span><span class="hljs-params">(selector, contexts, results)</span> </span>{
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
        len = contexts.length;
      <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      <span class="hljs-keyword">return</span> results;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>One-time assignments</p>

            </div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>Sort stability</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.sortStable = expando.split(<span class="hljs-string">""</span>).sort(sortOrder).join(<span class="hljs-string">""</span>) === expando;</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>Support: Chrome&lt;14
Always assume duplicates if they aren’t passed to the comparison function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.detectDuplicates = hasDuplicate;</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>Initialize against the default document</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    setDocument();</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
Detached nodes confoundingly follow <em>each other</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    support.sortDetached = assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div1)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>Should return 1, but returns 4 (following)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> div1.compareDocumentPosition(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>)) &amp; <span class="hljs-number">1</span>;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>Support: IE&lt;8
Prevent attribute/property “interpolation”
<a href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
      div.innerHTML = <span class="hljs-string">"&lt;a href='#'&gt;&lt;/a&gt;"</span>;
      <span class="hljs-keyword">return</span> div.firstChild.getAttribute(<span class="hljs-string">"href"</span>) === <span class="hljs-string">"#"</span> ;
    })) {
      addHandle(<span class="hljs-string">"type|href|height|width"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, name, isXML)</span> </span>{
        <span class="hljs-keyword">if</span> (!isXML) {
          <span class="hljs-keyword">return</span> elem.getAttribute(name, name.toLowerCase() === <span class="hljs-string">"type"</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>);
        }
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Use defaultValue in place of getAttribute(“value”)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!support.attributes || !assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
      div.innerHTML = <span class="hljs-string">"&lt;input/&gt;"</span>;
      div.firstChild.setAttribute(<span class="hljs-string">"value"</span>, <span class="hljs-string">""</span>);
      <span class="hljs-keyword">return</span> div.firstChild.getAttribute(<span class="hljs-string">"value"</span>) === <span class="hljs-string">""</span>;
    })) {
      addHandle(<span class="hljs-string">"value"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, name, isXML)</span> </span>{
        <span class="hljs-keyword">if</span> (!isXML &amp;&amp; elem.nodeName.toLowerCase() === <span class="hljs-string">"input"</span>) {
          <span class="hljs-keyword">return</span> elem.defaultValue;
        }
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>Support: IE&lt;9
Use getAttributeNode to fetch booleans when getAttribute lies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!assert(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(div)</span> </span>{
      <span class="hljs-keyword">return</span> div.getAttribute(<span class="hljs-string">"disabled"</span>) == <span class="hljs-literal">null</span>;
    })) {
      addHandle(booleans, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, name, isXML)</span> </span>{
        <span class="hljs-keyword">var</span> val;
        <span class="hljs-keyword">if</span> (!isXML) {
          <span class="hljs-keyword">return</span> (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
            val.value :
            elem[name] === <span class="hljs-literal">true</span> ? name.toLowerCase() : <span class="hljs-literal">null</span>;
        }
      });
    }

    <span class="hljs-keyword">return</span> Sizzle;

  }());</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
